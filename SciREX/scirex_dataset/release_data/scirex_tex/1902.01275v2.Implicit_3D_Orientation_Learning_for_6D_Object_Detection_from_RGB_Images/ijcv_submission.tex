%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
% Copy it to a new file with a new name and use it as the basis
% for your article. Delete % signs as needed.
%
% This template includes a few options for different layouts and
% content for various journals. Please consult a previous issue of
% your journal as needed.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% First comes an example EPS file -- just ignore it and
% proceed on the \documentclass line
% your LaTeX will extract the file if required
\begin{filecontents*}{example.eps}
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 19 19 221 221
%%CreationDate: Mon Sep 29 1997
%%Creator: programmed by hand (JK)
%%EndComments
gsave
newpath
  20 20 moveto
  20 220 lineto
  220 220 lineto
  220 20 lineto
closepath
2 setlinewidth
gsave
  .4 setgray fill
grestore
stroke
grestore
\end{filecontents*}
%
\RequirePackage{fix-cm}
%
%\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
%\documentclass[smallextended]{svjour3}       % onecolumn (second format)
\documentclass[twocolumn]{svjour3}          % twocolumn
%
\smartqed  % flush right qed marks, e.g. at end of proof
%
\usepackage{graphicx}




\usepackage{amsmath,amssymb} % define this before the line numbering.
\DeclareMathOperator*{\argmax}{argmax} 

\usepackage{color}
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:


%\usepackage[font=small,labelfont=bf]{caption}
%\usepackage[width=122mm,left=12mm,paperwidth=146mm,height=193mm,top=12mm,paperheight=217mm]{geometry}
\usepackage[acronym,toc]{glossaries} %{Abkürzungsverzeichnis (bei Bedarf)} 
\usepackage[toc,page]{appendix}

\usepackage{tikz}
%\usepackage{tikzscale}
\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{subfig}
%\usepackage{subcaption}

\usepackage{natbib}

\usepackage{booktabs}
\usepackage{adjustbox} 
%\usepackage{breakcites}
\usepackage{url}
\usepackage[
linkcolor						= blue,
citecolor						= green!90!black,
colorlinks   = true
]{hyperref}

\renewcommand\UrlFont{\color{blue}\rmfamily}

%\fboxsep1pt
\definecolor{darkgreen}{rgb}{0.498,0.749,0.498}
\definecolor{darkyellow}{rgb}{1.0,0.89,0.498}
\definecolor{darkred}{rgb}{1.0,0.498,0.498}
\renewcommand*{\glspostdescription}{} %Den Punkt am Ende jeder Beschreibung
\usepackage{pifont}
\newcommand{\OK}{\ding{51}}


%%%----- Abkürzungen ---------------------------------------
\newglossaryentry{VAE}{name=VAE,description={Variational Autoencoder},first={\glsentrydesc{VAE} (\glsentrytext{VAE})}}
\newglossaryentry{AE}{name={AE},description={Autoencoder},first={\glsentrydesc{AE} (\glsentrytext{AE})},plural=AEs,descriptionplural={Autoencoders},firstplural={\glsentrydescplural{AE} (\glsentryplural{AE})}}
\newglossaryentry{AAE}{name={AAE},description={Augmented Autoencoder},first={\glsentrydesc{AAE} (\glsentrytext{AAE})},plural=AAEs,descriptionplural={Augmented Autoencoders},firstplural={\glsentrydescplural{AAE} (\glsentryplural{AAE})}}
\newglossaryentry{CVAE}{name=CVAE,description={Conditional Variational Autoencoder},first={\glsentrydesc{CVAE} (\glsentrytext{CVAE})}}
\newglossaryentry{SSD}{name={SSD},description={Single Shot Multibox Detector},first={\glsentrydesc{SSD} (\glsentrytext{SSD})}}
\newglossaryentry{CNN}{name=CNN,description={Convolutional Neural Network},first={\glsentrydesc{CNN} (\glsentrytext{CNN})}, plural=CNNs,descriptionplural={Convolutional Neural Networks},firstplural={\glsentrydescplural{CNN} (\glsentryplural{CNN})}}
\newglossaryentry{SIFT}{name=SIFT,description={Scaled Invariant Feature Transform},first={Scaled Invariant Feature Transform (SIFT)}}
\newglossaryentry{SURF}{name=SURF,description={Speeded Up Robust Features},first={Speeded Up Robust Features (SURF)}}
\newglossaryentry{PnP}{name=PnP,description={Perspective-n-Point}, first={Perspective-n-Point (PnP)}}
\newglossaryentry{RF}{name=RF,description={Random Forrest},first={Random Forest (RF)},plural=RFs,descriptionplural={Random Forests},
	firstplural={\glsentrydescplural{RF} (\glsentryplural{RF})}}
\newglossaryentry{RANSAC}{name=RANSAC,description={Random Sample Consensus},first={RANSAC},}
\newglossaryentry{PCA}{name=PCA,description={Principal Component Analysis},first={Principal Component Analysis (PCA)}}
\newglossaryentry{LIDAR}{name={LIDAR},description={Light Detection And Ranging},first={\glsentrydesc{LIDAR} (\glsentrytext{LIDAR})}}
\newglossaryentry{kNN}{name={kNN},description={k-Nearest-Neighbor},first={\glsentrydesc{kNN} (\glsentrytext{kNN})}} 
\newglossaryentry{MLP}{name={MLP},description={Multilayer Perceptron},first={\glsentrydesc{MLP} (\glsentrytext{MLP})}, plural=MLPs,descriptionplural={Multilayer Perceptrons},firstplural={\glsentrydescplural{MLP} (\glsentryplural{MLP})}}
\newglossaryentry{EM}{name={EM},description={Expectation Maximization},first={\glsentrydesc{EM} (\glsentrytext{EM})}}
\newglossaryentry{6DOF}{name={6DOF},description={six degrees of freedom},first={\glsentrydesc{6DOF} (\glsentrytext{6DOF})}}
\newglossaryentry{ICP}{name={ICP},description={Iterative Closest Point},first={\glsentrydesc{ICP} (\glsentrytext{ICP})}}
\newglossaryentry{KL}{name={KL},description={Kullback-Leibler},first={\glsentrydesc{KL} (\glsentrytext{KL})}}
\newglossaryentry{VSD}{name={$err_{vsd}$},description={Visible Surface Discrepancy},first={\glsentrydesc{VSD} (\glsentrytext{VSD})}}
\newglossaryentry{mAP}{name={mAP},description={mean Average Precision},first={\glsentrydesc{mAP} (\glsentrytext{mAP})}}
\newglossaryentry{DA}{name={DA},description={Domain Adaptation},first={\glsentrydesc{DA} (\glsentrytext{DA})}}
\newglossaryentry{DR}{name={DR},description={Domain Randomization},first={\glsentrydesc{DR} (\glsentrytext{DR})}}
\newglossaryentry{GAN}{name={GAN},description={Generative Adversarial Network},first={\glsentrydesc{GAN}(\glsentrytext{GAN})},plural=GANs,descriptionplural={Generative Adversarial Networks},firstplural={\glsentrydescplural{GAN} (\glsentryplural{GAN})}}
\newglossaryentry{PPF}{name={PPF},description={Point Pair Features},first={\glsentrydesc{PPF} (\glsentrytext{PPF})}}


\begin{document}
%

\title{Augmented Autoencoders: Implicit 3D Orientation Learning for 6D Object Detection %\thanks{Grants or other notes
	%about the article that should go on the front page should be
	%placed here. General acknowledgments should be placed at the end of the article.}
}
%\subtitle{Do you have a subtitle?\\ If so, write it here}

%\titlerunning{Short form of title}        % if too long for running head

%\author{First Author         \and
%	Second Author %etc.
%}
%\author{Martin Sundermeyer
%	\and Zoltan-Csaba Marton  
%	\and Maximilian Durner
%	\and Rudolph Triebel}

\author{Martin Sundermeyer$^1$ \and Zoltan-Csaba Marton$^1$ \and Maximilian Durner$^1$  \and Rudolph Triebel$^{1,2}$}

%\authorrunning{Short form of author list} % if too long for running head

%\institute{F. Author \at
%	first address \\
%	Tel.: +123-45-678910\\
%	Fax: +123-45-678910\\
%	\email{fauthor@example.com}           %  \\
%	%             \emph{Present address:} of F. Author  %  if needed
%	\and
%	S. Author \at
%	second address
%}

\institute{$^1$German Aerospace Center (DLR), 82234 Wessling, Germany \\
	$^2$Technical University of Munich, 80333 Munich, Germany \\
	\email{\{martin.sundermeyer, zoltan.marton, \\maximilian.durner, rudolph.triebel\}@dlr.de}
	}


\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor
\maketitle

\begin{abstract}
	We propose a real-time RGB-based pipeline for object detection and 6D pose estimation. Our novel 3D orientation estimation is based on a variant of the Denoising Autoencoder that is trained on simulated views of a 3D model using Domain Randomization. 
	
	This so-called Augmented Autoencoder has several advantages over existing methods: It does not require real, pose-annotated training data, generalizes to various test sensors and inherently handles object and view symmetries. Instead of learning an explicit mapping from input images to object poses, it provides an implicit representation of object orientations defined by samples in a latent space. Our pipeline achieves state-of-the-art performance on the T-LESS dataset both in the RGB and RGB-D domain. We also evaluate on the LineMOD dataset where we can compete with other synthetically trained approaches.
	
	We further increase performance by correcting 3D orientation estimates to account for perspective errors when the object deviates from the image center and show extended results. Our code is available here 	
	\footnotemark \footnotetext{\url{https://github.com/DLR-RM/AugmentedAutoencoder}}
	
	\keywords{6D Object Detection \and Pose Estimation \and Domain Randomization \and Autoencoder \and Synthetic Data \and Symmetries}
\end{abstract}


\section{Introduction}
One of the most important components of modern computer vision systems
for applications such as mobile robotic manipulation and augmented
reality is a reliable and fast 6D object detection module. 
Although, there are very encouraging recent results from \cite{xiang2017posecnn,kehl2017ssd,hodan2017tless,wohlhart2015learning,vidal20186d,hinterstoisser2016going,tremblay2018deep}, a general, easily applicable, robust and fast solution is not available, yet. The
reasons for this are manifold. First and foremost, current solutions
are often not robust enough against typical challenges such as object
occlusions, different kinds of background clutter, and dynamic changes
of the environment. Second, existing methods often require certain
object properties such as enough textural
surface structure or an asymmetric shape to avoid
confusions. And finally, current systems are not efficient in terms
of run-time and in the amount and type of annotated training data they require.

\begin{figure*}[t]%tbp]
	\centering
	\captionsetup{width=\textwidth}
	\includegraphics[width=0.805\textwidth]{pipeline_with_scene_vertical_ext.pdf}
	%\caption{Our 6D Object Detection pipeline with homogeneous transformation $\hat{H}_{cam2obj} \in \mathcal{R}^{4x4}$ (top-right) and depth-refined result $H_{cam2obj}^{(refined)}$ (bottom-right)}	\label{fig:pipeline}
	\caption{Our full 6D Object Detection pipeline: after detecting an object (2D Object Detector), the object is quadratically cropped and forwarded into the proposed Augmented Autoencoder. In the next step, the bounding box scale ratio at the estimated 3D orientation $\hat{R'}_{obj2cam}$ is used to compute the 3D translation $\hat{t}_{obj2cam}$. The resulting euclidean transformation $\hat{H'}_{obj2cam}  \in \mathcal{R}^{4x4}$ already shows promising results as presented in \cite{sundermeyer2018implicit}, however it still lacks of accuracy given a translation in the image plane towards the borders. Therefore, the pipeline is extended by the Perspective Correction block which addresses this problem and results in more accurate 6D pose estimates $\hat{H}_{obj2cam}$ for objects which are not located in the image center. Additionally, given depth data, the result can be further refined ($\hat{H}_{obj2cam}^{(refined)}$) by applying an Iterative Closest Point post-processing (bottom).}	\label{fig:pipeline}
\end{figure*}

Therefore, we propose a novel approach that directly
addresses these issues. Concretely, our method operates on single
RGB images, which significantly increases the usability as no depth
information is required. We note though that depth maps may be
incorporated optionally to refine the estimation. As a first
step, we build upon state-of-the-art 2D Object Detectors of (\cite{liu2016ssd,lin2018focal}) which provide object bounding boxes and identifiers. On the resulting scene crops, we
employ our novel 3D orientation estimation algorithm, which is based on a
previously trained deep network architecture. While deep networks are
also used in existing approaches, our approach differs in that we do
not explicitly learn from 3D pose annotations during training. Instead, we
\emph{implicitly} learn representations from rendered 3D model views. This is accomplished by training a generalized version of the Denoising Autoencoder from \cite{vincent2010stacked}, that we call \textit{'\gls{AAE}'}, using a novel Domain Randomization strategy. 
Our approach has several
advantages: First, since the training is independent from concrete representations of object orientations within $SO(3)$ (e.g. 
quaternions), we can handle ambiguous poses caused by symmetric views because we avoid one-to-many mappings from images to orientations. Second, we learn representations that specifically encode 3D orientations while achieving
robustness against occlusion, cluttered backgrounds and generalizing to different environments and test sensors. Finally, the \gls{AAE} does not require any real pose-annotated training data. Instead, it is trained to encode 3D model views in a self-supervised way, overcoming the need of a large pose-annotated dataset. A schematic overview of the approach based on \cite{sundermeyer2018implicit} is shown in Fig \ref{fig:pipeline}.

\section{Related Work\label{sec:relwork}}

Depth-based methods (e.g. using \gls{PPF} from \cite{vidal20186d,hinterstoisser2016going}) have shown robust pose estimation performance on multiple datasets, winning the SIXD challenge \citep{sixd,hodan2018bop}. However, they usually rely on the computationally expensive evaluation of many pose hypotheses and do not take into account any high level features. Furthermore, existing depth sensors are often more sensitive to sunlight or specular object surfaces than RGB cameras.

\glspl{CNN} have revolutionized 2D object detection from RGB images \citep{ren2015faster,liu2016ssd,lin2018focal}. But, in comparison to 2D bounding box annotation, the effort of labeling real images with full 6D object poses is magnitudes higher, requires expert knowledge and a complex setup \citep{hodan2017tless}. 

Nevertheless, the majority of learning-based pose estimation methods, namely \cite{tekin2017real,wohlhart2015learning,brachmann2016uncertainty,rad2017bb8, xiang2017posecnn}, use real labeled images that you only obtain within pose-annotated datasets. 

In consequence, \cite{kehl2017ssd, wohlhart2015learning, tremblay2018deep, zakharov2019dpod} have proposed to train on synthetic images rendered from a 3D model, yielding a great data source with pose labels free of charge. However, naive training on synthetic data does not typically generalize to real test images. Therefore, a main challenge is to bridge the domain gap that separates simulated views from real camera recordings. 

\subsection{Simulation to Reality Transfer}

There exist three major strategies to generalize from synthetic to real data: 

\subsubsection{Photo-Realistic Rendering} The works of \cite{movshovitz2016useful,su2015render,mitash2017self,richter2016playing} have shown that photo-realistic renderings of object views
and backgrounds can in some cases benefit the generalization performance for tasks like object detection and viewpoint estimation. It is especially suitable in simple environments and performs well if jointly trained with a relatively small amount of real annotated images.  However, photo-realistic modeling is often imperfect and requires much effort. Recently, \cite{Hodan2019PhotorealisticIS} have shown promising results for 2D Object Detection trained on physically-based renderings.

\subsubsection{Domain Adaptation} \gls{DA} \citep{csurka2017domain} refers to leveraging training data from a source domain to a target domain of which a small portion of labeled data (supervised \gls{DA}) or unlabeled data (unsupervised \gls{DA}) is available. \glspl{GAN} have been deployed for unsupervised \gls{DA} by generating realistic from synthetic images to train classifiers \citep{shrivastava2017learning}, 3D pose estimators \citep{bousmalis2017unsupervised} and grasping algorithms \citep{bousmalis2017using}. While constituting a promising approach, \glspl{GAN} often yield fragile training results. 
Supervised \gls{DA} can lower the need for real annotated data, but does not abstain from it. 

\subsubsection{Domain Randomization} \gls{DR} builds upon the hypothesis that by training a model on rendered views in a variety of semi-realistic settings (augmented with random lighting conditions, backgrounds, saturation, etc.), it will also generalize to real images. \cite{tobin2017domain} demonstrated the potential of the \gls{DR} paradigm for 3D shape detection using \glspl{CNN}. \cite{hinterstoisser2017pre} showed that by training only the head network of FasterRCNN of \cite{ren2015faster} with randomized synthetic views of a textured 3D model, it also generalizes well to real images. It must be noted, that their rendering is almost photo-realistic as the textured 3D models have very high quality. \cite{kehl2017ssd} pioneered an end-to-end \gls{CNN}, called 'SSD6D', for 6D object detection that uses a moderate \gls{DR} strategy to utilize synthetic training data. The authors render views of textured 3D object reconstructions at random poses on top of MS COCO background images \citep{lin2014microsoft} while varying brightness and contrast. This lets the network generalize to real images and enables 6D detection at 10Hz. Like us, for accurate distance estimation they rely on \gls{ICP} post-processing using depth data. In contrast, we do not treat 3D orientation estimation as a classification task.

\subsection{Training Pose Estimation with SO(3) targets}

We describe the difficulties of training with fixed SO(3) parameterizations which will motivate the learning of view-based representations. 

\subsubsection{Regression} 

Since rotations live in a continuous space, it seems natural to directly regress a fixed SO(3) parameterizations like quaternions. However, representational constraints and pose ambiguities can introduce convergence issues as investigated by \cite{saxena2009learning}. In practice, direct regression approaches for full 3D object orientation estimation have not been very successful \citep{mahendran20173d}. Instead \cite{tremblay2018deep,tekin2017real,rad2017bb8} regress local 2D-3D correspondences and then apply a \gls{PnP} algorithm to obtain the 6D pose. However, these approaches can also not deal with pose ambiguities without additional measures (see Sec. \ref{sec:sym}).

\subsubsection{Classification} 

Classification of 3D object orientations requires a discretization of SO(3). Even rather coarse intervals of $\sim 5^o$ lead to over 50.000 possible classes. Since each class appears only sparsely in the training data, this hinders convergence. In SSD6D \citep{kehl2017ssd} the 3D orientation is learned by separately classifying a discretized viewpoint and in-plane rotation, thus reducing the complexity to $\mathcal{O}(n^2)$. However, for non-canonical views, e.g. if an object is seen from above, a change of viewpoint can be nearly equivalent to a change of in-plane rotation which yields ambiguous class combinations. In general, the relation between different orientations is ignored when performing one-hot classification.

\subsubsection{Symmetries} 
\label{sec:sym}
Symmetries are a severe issue when relying on fixed representations of 3D orientations since they cause pose ambiguities (Fig. \ref{fig:poseamb}). If not manually addressed, identical training images can have different orientation labels assigned which can significantly disturb the learning process. In order to cope with ambiguous objects, most approaches in literature are manually adapted \citep{wohlhart2015learning,hinterstoisser2012gradient,kehl2017ssd,rad2017bb8}. The strategies reach from ignoring one axis of rotation \citep{wohlhart2015learning,hinterstoisser2012gradient} over adapting the discretization according to the object \citep{kehl2017ssd} to the training of an extra \gls{CNN} to predict symmetries \citep{rad2017bb8}. These depict tedious, manual ways to filter out object symmetries (Fig. \ref{fig:sym}) in advance, but treating ambiguities due to self-occlusions (Fig. \ref{fig:view_sym}) and occlusions (Fig. \ref{fig:occl}) are harder to address. 

Symmetries do not only affect regression and classification methods, but any learning-based algorithm that discriminates object views solely by fixed SO(3) representations.


\begin{figure}[t]%tbp]
	\centering
	\subfloat[Object symmetries\label{fig:sym}]{{\includegraphics[width=0.29\textwidth,height=0.17\textheight,keepaspectratio]{symmetries.pdf} }}%
	\qquad
	\qquad
	\qquad
	\qquad
	\captionsetup{width=0.23\textwidth,,justification = raggedright}
	\subfloat[Self-occlusion \mbox{induced symmetries}\label{fig:view_sym}]{{\includegraphics[width=0.17\textwidth,height=0.15\textheight,keepaspectratio]{cup_sym.pdf} }}%
	\qquad
	\quad
	\captionsetup{width=0.205\textwidth,justification = raggedright}
	\subfloat[Occlusion \mbox{induced symmetries}\label{fig:occl}]{{\includegraphics[width=0.175\textwidth,height=0.15\textheight,keepaspectratio]{cup_sym_occl.pdf} }}%
	\captionsetup{width=0.9\textwidth}
	\caption{Causes of pose ambiguities}
	\label{fig:poseamb}%
\end{figure}

\subsection{Learning Representations of 3D orientations}

We can also learn indirect pose representations that relate object views in a low-dimensional space. The descriptor learning can either be self-supervised by the object views themselves or still rely on fixed SO(3) representations.
\begin{figure*}[t]
	\centering
	\begin{minipage}{0.454\linewidth}
		\centering
		\captionsetup{justification=centering,font=scriptsize,aboveskip=0.15cm,belowskip=0.25cm}
		\includegraphics[width=0.74\linewidth]{y_new.png}
		\caption*{\scriptsize{(a) $X_{s=1.0,t_{xy}=0.0,r \in [0,2\pi]}$}}
		\includegraphics[width=0.74\linewidth]{scale_new.png}
		\caption*{\scriptsize{(b) $X_{s=0.6,t_{xy}=0.0,r \in [0,2\pi]}$}}
		\includegraphics[width=0.74\linewidth]{trans_new.png}
		\caption*{\scriptsize{(c) $X_{s=1.0,t_{xy} \sim \mathcal{U}(-1,1),r \in [0,2\pi]}$}}
		\includegraphics[width=0.74\linewidth]{rand_new.png}
		\caption*{\scriptsize{(d) $X_{s\sim\mathcal{U}(0.5,1),t_{xy} \sim \mathcal{U}(-1,1),r \in [0,2\pi]}$}}
	\end{minipage}%
	\begin{minipage}{0.454\linewidth}		
		\captionsetup{justification=centering,aboveskip=0.03cm,belowskip=0.12cm}
		\resizebox{1.0\linewidth}{!}{
			\input{z1_ae_mid.tex}%
			\input{z2_ae_mid.tex}}
		\caption*{\scriptsize{(1) Autoencoder $\colorbox{darkgreen}{(a)}\longrightarrow \colorbox{darkgreen}{(a)}$ }}
		\resizebox{1.0\linewidth}{!}{
			\input{z1_ae_rand.tex}%
			\input{z2_ae_rand.tex}}
		\caption*{\scriptsize{(2) Autoencoder $\colorbox{darkyellow}{(d)} \longrightarrow \colorbox{darkyellow}{(d)}$}}
		\resizebox{1.0\linewidth}{!}{
			\input{z1_aae.tex}%
			\input{z2_aae.tex}}
		\caption*{\scriptsize{(3) Augmented Autoencoder $\colorbox{darkyellow}{(d)} \longrightarrow \colorbox{darkgreen}{(a)}$}}
	\end{minipage}
	\caption{Experiment on the dsprites dataset of \cite{dsprites17}. Left: 64x64 squares from four distributions (a,b,c and d) distinguished by \mbox{scale ($s$)} and translation ($t_{xy}$) that are used for training and testing. Right: Normalized latent dimensions $z_1$ and $z_2$ for all rotations ($r$) of the distribution (a), (b) or (c) after training ordinary \glspl{AE} (1),(2) and an \gls{AAE} (3) to reconstruct squares of the same orientation.}
	\label{fig:toy}
\end{figure*}


\subsubsection{Descriptor Learning}

\cite{wohlhart2015learning} introduced a \gls{CNN}-based descriptor learning approach using a triplet loss that minimizes/maximizes the Euclidean distance between similar/dissimilar object orientations. In addition, the distance between different objects is maximized.
Although mixing in synthetic data, the training also relies on pose-annotated sensor data. The approach is not immune against symmetries since the descriptor is built using explicit 3D orientations. Thus, the loss can be dominated by symmetric object views that appear the same but have opposite orientations which can produce incorrect average pose predictions.


\cite{balntas2017pose} extended this work by enforcing proportionality between descriptor and pose distances. They acknowledge the problem of object symmetries by weighting the pose distance loss with the depth difference of the object at the considered poses. This heuristic increases the accuracy on symmetric objects with respect to \cite{wohlhart2015learning}. 

Our work is also based on learning descriptors, but in contrast we train our Augmented Autoencoders (AAEs) such that the learning process itself is independent of any fixed SO(3) representation. The loss is solely based on the appearance of the reconstructed object views and thus symmetrical ambiguities are inherently regarded. Thus, unlike \cite{balntas2017pose,wohlhart2015learning} we abstain from the use of real labeled data during training and instead train completely self-supervised. This means that assigning 3D orientations to the descriptors only happens after the training.

\cite{kehl2016deep} train an Autoencoder architecture on random RGB-D scene patches from the LineMOD dataset \cite{hinterstoisser2011multimodal}. At test time, descriptors from scene and object patches are compared to find the 6D pose.
Since the approach requires the evaluation of a lot of patches, it takes about 670ms per prediction. Furthermore, using local patches means to ignore holistic relations between object features which is crucial if few texture exists. Instead we train on holistic object views and explicitly learn domain invariance.


\section{Method}

In the following, we mainly focus on the novel 3D orientation estimation technique based on the AAE.
\begin{figure*}[t]%tbp]
	\centering
	\captionsetup{width=0.9\textwidth}
	\includegraphics[width=0.8\textwidth]{training_process.pdf}
	\caption{Training process for the \gls{AAE}; a) reconstruction target batch $\pmb x$ of uniformly sampled SO(3) object views; b) geometric and color augmented input; c) reconstruction $\pmb{\hat{x}}$ after 40000 iterations}
	\label{fig:training_process}
\end{figure*}
\subsection{Autoencoders}

The original \gls{AE}, introduced by \cite{rumelhart1985learning}, is a dimensionality reduction technique for high dimensional data such as images, audio or depth. It consists of an Encoder $\Phi$ and a Decoder $\Psi$, both arbitrary learnable function approximators which are usually neural networks. The training objective is to reconstruct the input $x \in \mathcal{R}^{\mathcal{D}}$ after passing through a low-dimensional bottleneck, referred to as the latent representation $z \in \mathcal{R}^{n}$ with $n << \mathcal{D}$ :
\begin{equation}
\label{eq:yhat}
\hat{x} = (\Psi\circ\Phi)(x) = \Psi(z)
\end{equation}
The per-sample loss is simply a sum over the pixel-wise L2 distance
\begin{equation}
\label{eq:ae_loss}
\ell_{2} = \sum_{i \in \mathcal{D}} \parallel x_{i}-\hat{x}_{i}\parallel_2
\end{equation}
The resulting latent space can, for example, be used for unsupervised clustering.

\textbf{Denoising Autoencoders} introduced by \cite{vincent2010stacked} have a modified training procedure. Here, artificial random noise is applied to the input images $x \in \mathcal{R}^{\mathcal{D}}$ while the reconstruction target stays clean. The trained model can be used to reconstruct denoised test images. But how is the latent representation affected? 

\textbf{Hypothesis 1:} \textit{The Denoising AE produces latent representations which are invariant to noise because it facilitates the reconstruction of de-noised images.}

We will demonstrate that this training strategy actually enforces invariance not only against noise but against a variety of different input augmentations. Finally, it allows us to bridge the domain gap between simulated and real data.

\subsection{Augmented Autoencoder}
\label{sec:aae}

The motivation behind the \gls{AAE} is to control what the latent representation encodes and which properties are ignored. We apply random augmentations $f_{augm}(.)$ to the input images $x \in \mathcal{R}^{\mathcal{D}}$ against which the encoding should become invariant. The reconstruction target remains eq. \eqref{eq:ae_loss} but eq. \eqref{eq:yhat} becomes
\begin{equation}
\hat{x} = (\Psi\circ\Phi\circ f_{augm})(x) = (\Psi\circ\Phi)(x') = \Psi(z')
\end{equation}
To make evident that \textbf{Hypothesis 1} holds for geometric transformations, we learn latent representations of binary images depicting a 2D square at different scales, in-plane translations and rotations. Our goal is to encode only the in-plane rotations $r \in [0,2 \pi]$ in a two dimensional latent space $z \in \mathcal{R}^{2}$ independent of scale or translation. Fig. \ref{fig:toy} depicts the results after training a \gls{CNN}-based \gls{AE} architecture similar to the model in Fig. \ref{fig:ae_arch}. It can be observed that the \glspl{AE} trained on reconstructing squares at fixed scale and translation (1) or random scale and translation (2) do not clearly encode rotation alone, but are also sensitive to other latent factors. Instead, the encoding of the \gls{AAE} (3) becomes invariant to translation and scale such that all squares with coinciding orientation are mapped to the same code. Furthermore, the latent representation is much smoother and the latent dimensions imitate a shifted sine and cosine function with frequency $f=\frac{4}{2 \pi}$ respectively. The reason is that the square has two perpendicular axes of symmetry, i.e. after rotating $\frac{\pi}{2}$ the square appears the same. This property of representing the orientation based on the appearance of an object rather than on a fixed parametrization is valuable to avoid ambiguities due to symmetries when teaching 3D object orientations.

\begin{figure*}[t]%tbp]
	\centering
	\captionsetup{width=\textwidth}
	\includegraphics[width=\textwidth]{AE_arch.pdf}
	\caption{Autoencoder CNN architecture with occluded test input, "resize2x" depicts nearest-neighbor upsampling}
	\label{fig:ae_arch}
\end{figure*}
\subsection{Learning 3D Orientation from Synthetic Object Views}
Our toy problem showed that we can explicitly learn representations of object in-plane rotations using a geometric augmentation technique. Applying the same geometric input augmentations we can encode the whole SO(3) space of views from a 3D object model (CAD or 3D reconstruction) while being robust against inaccurate object detections. However, the encoder would still be unable to relate image crops from real RGB sensors because 
(1) the 3D model and the real object differ, (2) simulated and real lighting conditions differ, (3) the network can't distinguish the object from background clutter and foreground occlusions. 
Instead of trying to imitate every detail of specific real sensor recordings in simulation we propose a Domain Randomization (DR) technique within the \gls{AAE} framework to make the encodings invariant to insignificant environment and sensor variations. The goal is that the trained encoder treats the differences to real camera images as just another irrelevant variation. Therefore, while keeping reconstruction targets clean, we randomly apply additional augmentations to the input training views: (1) rendering with random light positions and randomized diffuse and specular reflection (simple Phong model \citep{phong1975illumination} in OpenGL), (2) inserting random background images from the Pascal VOC dataset \citep{pascalvoc2012}, (3) varying image contrast, brightness, Gaussian blur and color distortions, (4) applying occlusions using random object masks or black squares. Fig. \ref{fig:training_process} depicts an exemplary training process for synthetic views of object 5 from T-LESS \citep{hodan2017tless}.

\begin{table}[t]
	\scriptsize
	\centering
	\captionsetup{width=0.9\columnwidth}
	\caption{Augmentation Parameters of \gls{AAE}; Scale and translation is in relation to image shape and occlusion is in proportion of the object mask}
	\begin{tabular}{cc|cc}
		\toprule
		& 50\% chance &\multicolumn{2}{c}{light (random position) } \\
		& (30\% per channel) & \multicolumn{2}{c}{\& geometric}\\
		\midrule
		add & $\mathcal{U}(-0.1,0.1)$ & ambient &$0.4$ \\
		contrast & $\mathcal{U}(0.4,2.3)$ &diffuse &$\mathcal{U}(0.7,0.9)$\\
		multiply & $\mathcal{U}(0.6,1.4)$ & specular&$\mathcal{U}(0.2,0.4)$ \\
		invert &  & scale &$\mathcal{U}(0.8,1.2)$\\
		gaussian blur & $\sigma \sim \mathcal{U}(0.0,1.2)$ & translation & $\mathcal{U}(-0.15,0.15)$\\
		&& occlusion & $\in [0,0.25]$ 
	\end{tabular}
	\label{tab:aug_strong_col}
\end{table}


\begin{figure}[t]%tbp]
	\centering
	
	\centering
	\captionsetup{width=0.95\columnwidth}
	\includegraphics[width=0.82\columnwidth]{reconstruction_imgs.pdf}
	\caption{\gls{AAE} decoder reconstruction of LineMOD (left) and T-LESS (right) scene crops}
	\label{fig:reconst_ex}
	
\end{figure}
\subsection{Network Architecture and Training Details}

The convolutional Autoencoder architecture that is used in our experiments is depicted in Fig. \ref{fig:ae_arch}. 
We use a bootstrapped pixel-wise L2 loss, first introduced by \cite{wu2016bridging}. Only the pixels with the largest reconstruction errors contribute to the loss. Thereby, finer details are reconstructed and the training does not converge to local minima like reconstructing black images for all views. In our experiments, we choose a bootstrap factor of $k=4$ per image, meaning that $\frac{1}{4}$ of all pixels contribute to the loss.
Using OpenGL, we render 20000 views of each object uniformly at random 3D orientations and constant distance along the camera axis (700mm). The resulting images are quadratically cropped using the longer side of the bounding box and resized (nearest neighbor) to $128 \times 128 \times 3$ as shown in Fig. \ref{fig:training_process}. All geometric and color input augmentations besides the rendering with random lighting are applied online during training at uniform random strength, parameters are found in Tab. \ref{tab:aug_strong_col}.
We use the Adam \citep{kingma2014adam} optimizer with a learning rate of $2\times 10^{-4}$, Xavier initialization \citep{glorot2010understanding}, a \mbox{batch size = 64} and 40000 iterations which takes $\sim 4$ hours on a single Nvidia Geforce GTX 1080.
\begin{figure*}[t]%tbp]
	\centering
	\captionsetup{width=0.93\textwidth}
	\includegraphics[width=0.9\textwidth]{test_pipeline.pdf}
	\caption{Top: creating a codebook from the encodings of discrete synthetic object views; bottom: object detection and 3D orientation estimation using the nearest neighbor(s) with highest cosine similarity from the codebook}
	\label{fig:test_pipeline}
\end{figure*}
\subsection{Codebook Creation and Test Procedure}


After training, the \gls{AAE} is able to extract a 3D object from real scene crops of many different camera sensors (Fig. \ref{fig:reconst_ex}). The clarity and orientation of the decoder reconstruction is an indicator of the encoding quality. To determine 3D object orientations from test scene crops we create a codebook (Fig. \ref{fig:test_pipeline} (top)):
\begin{itemize}
	\item[1)]  Render clean, synthetic object views at nearly equidistant viewpoints from a full view-sphere (based on a refined icosahedron \citep{hinterstoisser2008simultaneous})
	\item[2)] Rotate each view in-plane at fixed intervals to cover the whole SO(3)
	\item[3)] Create a codebook by generating latent codes $z \in \mathcal{R}^{128}$ for all resulting images and assigning their corresponding rotation $R_{cam2obj} \in \mathcal{R}^{3x3}$
\end{itemize}

At test time, the considered object(s) are first detected in an RGB scene. The image is quadratically cropped using the longer side of the bounding box multiplied with a padding factor of 1.2 and resized to match the encoder input size. The padding accounts for imprecise bounding boxes. After encoding we compute the cosine similarity between the test code $z_{test} \in \mathcal{R}^{128}$ and all codes $z_{i} \in \mathcal{R}^{128}$ from the codebook:
\begin{equation}
cos_i = \frac{\pmb z_i \;\pmb z_{test}}{\lVert \pmb z_i \rVert \lVert \pmb z_{test} \rVert}
\end{equation}
The highest similarities are determined in a \gls{kNN} search and the corresponding rotation matrices $ \{R_{kNN}\}$ from the codebook are returned as estimates of the 3D object orientation. For the quantitative evaluation we use $k=1$, however the next neighbors can yield valuable information on ambiguous views and could for example be used in particle filter based tracking. We use cosine similarity because (1) it can be very efficiently computed on a single GPU even for large codebooks. In our experiments we have 2562 equidistant viewpoints $\times$ 36 in-plane rotation = 92232 total entries. (2) We observed that, presumably due to the circular nature of rotations, scaling a latent test code does not change the object orientation of the decoder reconstruction (Fig. \ref{fig:scale}).

\begin{figure}[t]%tbp]
	\centering
		\captionsetup{width=0.99\columnwidth}
		\includegraphics[width=0.7\columnwidth]{going_along_latent_vector_direction.pdf}
		\caption{\gls{AAE} decoder reconstruction of a test code $z_{test} \in \mathcal{R}^{128}$ scaled by a factor $s\in[0,2.5]$}
		\label{fig:scale}
\end{figure}
\begin{table}[t]
	\scriptsize
	\centering
	\captionsetup{width=0.9\columnwidth}
	\caption{Augmentation Parameters for Object Detectors, top five are applied in random order; bottom part describes phong lighting from random light positions}
	\begin{tabular}{cc|cc}
		\toprule
		&chance & SIXD train & Rendered \\
		&(per ch.)& & 3D models \\
		\midrule
		add & 0.5 (0.15) & $\mathcal{U}(-0.08,0.08)$  &$\mathcal{U}(-0.1,0.1)$ \\
		contrast norm. &0.5 (0.15)& $\mathcal{U}(0.5,2.2)$  &$\mathcal{U}(0.5,2.2)$\\
		multiply & 0.5 (0.25) & $\mathcal{U}(0.6,1.4)$ &$\mathcal{U}(0.5,1.5)$ \\
		gaussian blur & 0.2 & $\sigma \sim \mathcal{U}(0.5,1.0)$  & $\sigma = 0.4$ \\
		gaussian noise & 0.1 (0.1) & $\sigma = 0.04$ & - \\
		\midrule
		ambient & 1.0 & -&$0.4$ \\
		diffuse &1.0&-&$\mathcal{U}(0.7,0.9)$ \\
		specular &1.0&-&$\mathcal{U}(0.2,0.4)$ 
	\end{tabular}
	\label{tab:aug_det}
\end{table}
\subsection{Extending to 6D Object Detection}
\subsubsection{Training the 2D Object Detector.} We finetune the 2D Object Detectors using the object views on black background  which are provided in the training datasets of LineMOD and T-LESS. In LineMOD we additionally render domain randomized views of the provided 3D models and freeze the backbone like in \cite{hinterstoisser2017pre}. Multiple object views are sequentially copied into an empty scene at random translation, scale and in-plane rotation. Bounding box annotations are adapted accordingly. If an object view is more than 40\% occluded, we re-sample it. Then, as for the \gls{AAE}, the black background is replaced with Pascal VOC images. The randomization schemes and parameters can be found in Table \ref{tab:aug_det}. In T-LESS we train SSD \citep{liu2016ssd} with VGG16 backbone and RetinaNet \citep{lin2018focal} with ResNet50 backbone which is slower but more accurate, on LineMOD we only train RetinaNet. For T-LESS we generate 60000 training samples from the provided training dataset and for LineMOD we generate 60000 samples from the training dataset plus 60000 samples from 3D model renderings with randomized lighting conditions (see Table \ref{tab:aug_det}). The RetinaNet achieves 0.73mAP@0.5IoU on T-LESS and 0.62mAP@0.5IoU on LineMOD. On Occluded LineMOD, the detectors trained on the simplistic renderings failed to achieve good detection performance. However, recent work of  \cite{Hodan2019PhotorealisticIS} quantitatively investigated the training of 2D detectors on synthetic data and they reached decent detection performance on Occluded LineMOD by fine-tuning FasterRCNN on photo-realistic synthetic images showing the feasibility of a purely synthetic pipeline.

\subsubsection{Projective Distance Estimation}
\label{sec:proj}
We estimate the full 3D translation $t_{real}$ from camera to object center, similar to \cite{kehl2017ssd}. Therefore, we save the 2D bounding box for each synthetic object view in the codebook and compute its diagonal length $\| bb_{syn,i} \|$. At test time, we compute the ratio between the detected bounding box diagonal $\| bb_{real} \|$ and the corresponding codebook diagonal $\| bb_{syn,{\argmax} (cos_i) }\|$, i.e. at similar orientation. The pinhole camera model yields the distance estimate $\hat{t}_{real,z}$
\begin{equation}
\label{eq:dist}
\hat{t}_{real,z} = t_{syn,z} \times   \frac{\| bb_{syn,{\argmax} (cos_i)} \|}{\| bb_{real} \|} \times \frac{f_{real}}{f_{syn}}
\end{equation} 
with synthetic rendering distance $t_{syn,z}$ and focal lengths $f_{real}$, $f_{syn}$ of the real sensor and synthetic views. It follows that

\begin{align}
\boldsymbol{\Delta \hat{t}} &= \hat{t}_{real,z} \boldsymbol{K_{real}^{-1}} \boldsymbol{bb_{real,c}} - t_{syn,z}\boldsymbol{ K_{syn}^{-1}} \boldsymbol{bb_{syn,c}}
\\[+0.5em]
\boldsymbol{\hat{t}_{real}} &= \boldsymbol{t_{syn}} + \boldsymbol{\Delta \hat{t}}
\end{align}

where $\boldsymbol{\Delta \hat{t}}$ is the estimated vector from the synthetic to the real object center, $\boldsymbol{K_{real}}, \boldsymbol{K_{syn}}$ are the camera matrices, $\boldsymbol{bb_{real,c}},\boldsymbol{bb_{syn,c}}$ are the bounding box centers in homogeneous coordinates and $\boldsymbol{\hat{t}_{real}}, \boldsymbol{t_{syn}} = (0,0,t_{syn,z})$ are the translation vectors from camera to object centers. In contrast to \cite{kehl2017ssd}, we can predict the 3D translation for different test intrinsics.

\subsubsection{Perspective Correction}
While the codebook is created by encoding centered object views, the test image crops typically do not originate from the image center. Naturally, the appearance of the object view changes when translating the object in the image plane at constant object orientation. This causes a noticeable error in the rotation estimate from the codebook towards the image borders. However, this error can be corrected by determining the object rotation that approximately preserves the appearance of the object when translating it to our estimate $\boldsymbol{\hat{t}_{real}}$.
\begin{align}
\label{eq:correct}
\left( \begin{array}{c}\alpha_x\\\alpha_y \end{array} \right) 
 &= 
 \left( \begin{array}{c} -\arctan(\hat{t}_{real,y} / \hat{t}_{real,z})  \\ \arctan(\hat{t}_{real,x} / \sqrt{\hat{t}_{real,z}^2 + \hat{t}^2_{real,y}}) \end{array} \right)\\[+1em]
 \boldsymbol{\hat{R}_{obj2cam}} &= \boldsymbol{ R_y(}\alpha_y\boldsymbol{)R_x(}\alpha_x\boldsymbol{)\hat{R}'_{obj2cam}}
\end{align}
where $\alpha_x, \alpha_y$ describe the angles around the camera axes and $\boldsymbol{ R_y(}\alpha_y\boldsymbol{)R_x(}\alpha_x\boldsymbol{)}$ the corresponding rotation matrices to correct the initial rotation estimate $\boldsymbol{\hat{R}'_{obj2cam}}$ from object to camera.
The perspective corrections give a notable boost in accuracy as reported in Table \ref{tab:persp}. If strong perspective distortions are expected at test time, the training images $x'$ could also be recorded at random distances as opposed to constant distance. However, in the benchmarks, perspective distortions are minimal and consequently random online image-plane scaling of $x'$ is sufficient. 

\subsubsection{ICP Refinement}
\label{sec:icp}
Optionally, the estimate is refined on depth data using a point-to-plane \gls{ICP} approach with adaptive thresholding of correspondences based on \cite{chen1992object, zhang1994iterative} taking an average of $\sim 320ms$. The refinement is first applied in direction of the vector pointing from camera to the object where most of the RGB-based pose estimation errors stem from and then on the full 6D pose.

\subsubsection{Inference Time}
The \gls{SSD} with VGG16 base and 31 classes plus the \gls{AAE} (Fig. \ref{fig:ae_arch}) with a codebook size of $92232 \times 128$ yield the average inference times depicted in Table \ref{tab:infer}. We conclude that the RGB-based pipeline is real-time capable at $\sim$42Hz on a Nvidia GTX 1080. This enables augmented reality and robotic applications and leaves room for tracking algorithms. Multiple encoders (15MB) and corresponding codebooks (45MB each) fit into the GPU memory, making multi-object pose estimation feasible.


\begin{table}[t]
		\scriptsize
		\centering
		\captionsetup{width=0.8\columnwidth}
		\caption{Inference time of the RGB pipeline using SSD on CPUs \textbf{or} GPU}
		%\begin{adjustbox}{max width=0.4\columnwidth}
		\begin{tabular}{ccc}
			\toprule
			& 4 CPUs & GPU\\
			\midrule
			SSD & - & \textbf{$\sim$17ms}\\
			Encoder & $\sim$100ms & \textbf{$\sim$5ms}\\
			Cosine Similarity & 2.5ms & \textbf{1.3ms}\\
			Nearest Neighbor &	\textbf{0.3ms} &	3.2ms\\
			Projective Distance &	\textbf{0.4ms} &	-\\
			\midrule
			&\multicolumn{2}{c}{\textbf{$\sim$24ms}}\\
		\end{tabular}
		%\end{adjustbox}
		\label{tab:infer}
\end{table}
	%
\begin{table}[t]
		\centering
		\scriptsize
		\captionsetup{width=0.8\columnwidth}
		\caption{Single object pose estimation runtime w/o refinement}
		%\begin{adjustbox}{max width=0.4\columnwidth}
		\begin{tabular}{cc}
			\toprule
			Method & fps \\
			\midrule
			\cite{vidal20186d} & $0.2$\\
				\\[-0.6em]
			\cite{brachmann2016uncertainty} & 2 \\
			\\[-0.6em]
			\cite{kehl2016deep} & 2 \\
			\\[-0.6em]
			\cite{rad2017bb8} & 4 \\
			\\[-0.6em]
			\cite{kehl2017ssd} & 12 \\
			\\[-0.6em]
			OURS & 13 (RetinaNet) \\
			\\[-0.6em]
				&  42 (SSD) \\
			\\[-0.6em]
			\cite{tekin2017real} & 50 \\
		\end{tabular}
		%\end{adjustbox}
		\label{tab:runtime_compare}
		

\end{table}

\begin{table*}[t]
	\centering
	\scriptsize
	\captionsetup{justification=centering,width=.8\textwidth}
	\caption{Ablation study on color augmentations for different test sensors. Object 5 tested on all scenes, T-LESS \cite{hodan2017tless}. Standard deviation of three runs in brackets.}
	\begin{adjustbox}{max width=.8\textwidth}
		\begin{tabular}{ccccccccc}
			\toprule
			\textbf{Train RGB} & \textbf{Test RGB}
			& dyn. light & add & contrast & multiply & invert & \textbf{AUC\textsubscript{vsd}}\\
			\midrule
			3D Reconstruction & Primesense &  \OK  &  &  &  &  & 0.472 ($\pm$ 0.013)\\
			(synthetic)& (real) & \OK  & \OK &  &  &   & 0.611 ($\pm$ 0.030)\\
			&& \OK  & \OK & \OK &  &  & 0.825 ($\pm$ 0.015)\\
			&& \OK  & \OK & \OK &  \OK&   & 0.876 ($\pm$ 0.019)\\
			&& \OK  & \OK & \OK &  \OK&  \OK & \textbf{0.877} ($\pm$ 0.005)\\
			&&    & \OK & \OK &  \OK&  & 0.861 ($\pm$ 0.014)\\   
			\midrule
			Primesense (real) & Primesense (real) & & \OK & \OK &  \OK& & 0.890 ($\pm$ 0.003)\\
			\midrule
			3D Reconstruction&Kinect &  \OK  &  &  &  &  & 0.461 ($\pm$ 0.022)\\
			(synthetic)&(real) &  \OK  & \OK &  &  &   & 0.580 ($\pm$ 0.014)\\
			&&  \OK  & \OK & \OK &  &  & 0.701 ($\pm$ 0.046)\\
			&&  \OK  & \OK & \OK &  \OK&   & 0.855 ($\pm$ 0.016)\\
			&&  \OK  & \OK & \OK &  \OK&  \OK & 0.897 ($\pm$ 0.008)\\
			&&    & \OK & \OK &  \OK&   & \textbf{0.903} ($\pm$ 0.016)\\
			\midrule
			Kinect (real)& Kinect (real) & & \OK & \OK &  \OK& & 0.917 ($\pm$ 0.007)\\
		\end{tabular}
	\end{adjustbox}
	\label{tab:auc_aug}
\end{table*}
\begin{figure*}[t]%tbp]
	
	\centering
	
	\subfloat[Effect of latent space size, standard deviation in red \label{fig:latent}]{{\includegraphics[width=0.3\textwidth]{latent_size.pdf}}} \qquad
	\subfloat[Training on CAD model (bottom) vs. textured 3D reconstruction (top) \label{fig:cad_vs_reconst}]{{\includegraphics[width=0.44\textwidth]{cad_vs_reconst.pdf}}}
	\captionsetup{}
	\caption{Testing object 5 on all 504 Kinect RGB views of scene 2 in T-LESS}
	
\end{figure*}

\section{Evaluation}

We evaluate the \gls{AAE} and the whole 6D detection pipeline on the T-LESS \citep{hodan2017tless} and LineMOD \citep{hinterstoisser2011multimodal} datasets.
\subsection{Test Conditions}
\label{sec:cond}
Few RGB-based pose estimation approaches (e.g. \cite{kehl2017ssd,ulrich2009cad}) only rely on 3D model information. Most methods like \cite{wohlhart2015learning,balntas2017pose,brachmann2016uncertainty} make use of real pose annotated data and often even train and test on the same scenes (e.g. at slightly different viewpoints, as in the official LineMOD benchmark). It is common practice to ignore in-plane rotations or to only consider object poses that appear in the dataset \citep{rad2017bb8,wohlhart2015learning} which also limits applicability. Symmetric object views are often individually treated \citep{rad2017bb8,balntas2017pose} or ignored \citep{wohlhart2015learning}. 
The SIXD challenge \citep{sixd} is an attempt to make fair comparisons between 6D localization algorithms by prohibiting the use of test scene pixels. We follow these strict evaluation guidelines, but treat the harder problem of 6D detection where it is unknown which of the considered objects are present in the scene. This is especially difficult in the T-LESS dataset since objects are very similar. 
We train the AAEs on the reconstructed 3D models, except for object 19-23 where we train on the CAD models because the pins are missing in the reconstructed plugs. 

We noticed, that the geometry of some 3D reconstruction in T-LESS is slightly inaccurate which badly influences the RGB-based distance estimation (Sec. \ref{sec:proj}) since the synthetic bounding box diagonals are wrong. Therefore, in a second training run we only train on the 30 CAD models.

{\setlength{\tabcolsep}{0.2em}
	\begin{table*}[t]
	\scriptsize
	\centering
	\captionsetup{justification=centering}
	\caption{T-LESS: Object recall for $err_{vsd}<0.3$ on all Primesense test scenes (SIXD/BOP benchmark from \cite{hodan2018bop}). $RGB^\dag$ depicts training with 3D reconstructions, except objects 19-23 $\longrightarrow$ CAD models; $RGB^\ddag$ depicts training on untextured CAD models only }
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{r|ccc|ccccc|cc}
			\toprule
			& \multicolumn{3}{c|}{\textbf{AAE}} &\textbf{AAE}& &&&  & \multicolumn{2}{|c}{\textbf{AAE}}\\
			
			& SSD& \multicolumn{2}{|c|}{RetinaNet}& RetinaNet & \citeauthor{brachmann2016uncertainty}&  \citeauthor{kehl2016deep} & \citeauthor{vidal20186d} & \citeauthor{drost2010model} & \multicolumn{2}{|c}{w/ GT 2D BBs}\\
			
			Data & $RGB^\dag$ & $RGB^\dag$ &$RGB^\ddag$ & $RGB^\dag$+Depth(ICP)  & RGB-D &RGB-D +ICP  & Depth +ICP & Depth +edge & $RGB^\dag$ & +Depth(ICP)\\     
			\midrule                                                  
			1 &       5.65 &   		9.48 &   12.67 &   67.95  & 8&  7 &  43 &   53 & 12.67 &     85.98 \\
			2 &       5.46 &   		13.24 &  16.01 &   70.62  & 10&     10 &  47 &   44 & 11.47 &     86.27 \\
			3 &       7.05 &   		12.78 &  22.84 &   78.39  & 21&     18 &  69 &   61 & 13.32 &     90.80 \\
			4 &       4.61 &   		6.66 &   6.70 &    57.00  & 4&  24 &  63 &   67 & 12.88 &     84.20 \\
			5 &      36.45 &   		36.19 &  38.93 &   77.18  & 46&     23 &  69 &   71 & 67.37 &     90.14 \\
			6 &      23.15 &   		20.64 &  28.26 &   72.75  & 19&     10 &  67 &   73 & 54.21 &     90.58 \\
			7 &      15.97 &   		17.41 &  26.56 &   83.39  & 52&     0 &  77 &   75 & 38.10 &     86.94 \\
			8 &       10.86 &  		21.72 &  18.01 &   78.08  & 22&     2 &  79 &  89 & 24.83 &     91.79 \\
			9 &      19.59 &   		39.98 &  33.36 &   88.64  & 12&     11 &  90 &   92 & 49.06 &     91.09 \\
			10 &       10.47 & 		13.37 &  33.15 &   84.47  & 7&      17 &  68 &  72 & 15.67 &     84.67 \\
			11 &       4.35 &  		7.78 &   17.94 &   56.01  & 3&  5 &  69 &   64 & 16.64 &     77.01 \\
			12 &       7.80 &  		9.54 &   18.38 &   63.23  & 3&  1 &  82 &   81 & 33.57 &     79.32 \\
			13 &       3.30 &  		4.56 &   16.20 &   43.55  & 0&  0 &  56 &   53 & 15.29 &     64.38 \\
			14 &       2.85 &  		5.36 &   10.58 &   25.58  & 0&  9 &  47 &   46 & 50.14 &     71.37 \\
			15 &       7.90 &  		27.11 &  40.50 &   69.81  & 0&  12 &  52 &   55 & 52.01 &     73.90 \\
			16 &      13.06 &  		22.04 &  35.67 &   84.55  & 5&  56 &  81 &   85 & 36.71 &     87.58 \\
			17 &      41.70 &  		66.33 &  50.47 &   74.29  & 3&  52 &  83 &   88 & 81.44 &     78.88 \\
			18 &      47.17 &  		14.91 &  33.63 &   83.12  & 54&     22 &  80 &   78 & 55.48 &     85.64 \\
			19 &       15.95 & 		23.03 &  23.03 &   58.13  & 38&     35 &  55 &  55 & 53.07 &     82.71 \\
			20 &       2.17 &  		5.35 &   5.35 &    26.73  & 1&  5 &  47 &   47 & 38.97 &     70.87 \\
			21 &       19.77 & 		19.82 &  19.82 &   53.48  & 39&     26 &  63 &  55 & 53.45 &     86.83 \\
			22 &       11.01 & 	    20.25 &  20.25 &   60.49  & 19&     27 & 70 &  56 & 49.95 &     84.20 \\
			23 &       7.98 &  		19.15 &  19.15 &   62.69  & 61&     71 &  85 &  84 & 36.74 &     76.40 \\
			24 &       4.74 &  		4.54 &   27.94 &   62.99  & 1&  36 &  70 &   59 & 11.75 &     84.38 \\
			25 &      21.91 &  		19.07 &  51.01 &   73.33  & 16&     28 &  48 &   47 & 37.73 &     87.53 \\
			26 &       10.04 & 		12.92 &  33.00 &   67.00  & 27&     51 &  55 &  69 & 29.82 &     90.26 \\
			27 &       7.42 &  		22.37 &  33.61 &   82.16  & 17&     34 &  60 &   61 & 23.30 &     84.43 \\
			28 &      21.78 &  		24.00 &  30.88 &   83.51  & 13&     54 &  69 &   80 & 43.97 &     89.84 \\
			29 &      15.33 &  		27.66 &  35.57 &   74.45  & 6&  86 &  65 &   84 & 57.82 &     88.58 \\
			30 &      34.63 &  		30.53 &  44.33 &   93.65  & 5&  69 &  84 &   89 & 72.81 &     95.01 \\
			\midrule
			Mean &14.67 &19.26 & \textbf{26.79} &\textbf{68.57}& 17.84 &24.60& 66.51 &  67.50 &38.34 &\textbf{84.05}\\
			\midrule
			Time(s) & \textbf{0.024} &  0.077 &  0.077 &\textbf{0.4}& 13.5 & 1.8& 4.7 &  21.5 & \textbf{0.006} &0.33
		\end{tabular}
	\end{adjustbox}
	
	\label{tab:tless}
\end{table*}

	{\setlength{\tabcolsep}{0.4em}
	\begin{table}
		\centering
		\small
		\captionsetup{width=\textwidth}
		\caption{Effect of Perspective Corrections on T-LESS}
		%\begin{adjustbox}{max width=0.4\textwidth}
		\begin{tabular}{c|c}
			\toprule
			Method & $RGB^\dag$  \\
			\midrule
			w/o correction & 18.35 \\
			w/ correction & \textbf{19.26 (+0.91)} 
		\end{tabular}
		%\end{adjustbox}
		\label{tab:persp}
		
	\end{table}



\subsection{Metrics}

\cite{hodan2016evaluation}  introduced the \gls{VSD}, an ambiguity-invariant pose error function that is determined by the distance between the estimated and ground truth visible object depth surfaces. As in the SIXD challenge, we report the recall of correct 6D object poses at $err_{vsd} < 0.3$ with tolerance $\tau = 20mm$ and $>10\%$ object visibility. Although the Average Distance of Model Points (ADD) metric introduced by \cite{hinterstoisser2012model} cannot handle pose ambiguities, we also present it for the LineMOD dataset following the official protocol in \cite{hinterstoisser2012model}. For objects with symmetric views (eggbox, glue), \cite{hinterstoisser2012model} adapts the metric by calculating the average distance to the \textit{closest} model point. \cite{Manhardt_2018_ECCV} has noticed inaccurate intrinsics and sensor registration errors between RGB and D in the LineMOD dataset. Thus, purely synthetic RGB-based approaches, although visually correct, suffer from false pose rejections. The focus of our experiments lies on the T-LESS dataset.

 In our ablation studies we also report the $AUC_{vsd}$, which represents the area under the '$err_{vsd}$ vs. recall' curve: 
\begin{align}
AUC_{vsd} = \int_0^1recall(err_{vsd})\,derr_{vsd}
\end{align}

	\subsection{Ablation Studies}
	To assess the \gls{AAE} alone, in this subsection we only predict the 3D orientation of Object 5 from the T-LESS dataset on Primesense and Kinect RGB scene crops. 
	Table \ref{tab:auc_aug} shows the influence of different input augmentations. 
	It can be seen that the effect of different color augmentations is cumulative. For textureless objects, even the inversion of color channels seems to be beneficial since it prevents overfitting to synthetic color information. Furthermore, training with real object recordings provided in T-LESS with random Pascal VOC background and augmentations yields only slightly better performance than the training with synthetic data.
	Fig. \ref{fig:latent} depicts the effect of different latent space sizes on the 3D pose estimation accuracy. Performance starts to saturate at $dim = 64$. 
	

\begin{table*}[t]
	\scriptsize
	\captionsetup{justification=centering,width=0.8\textwidth}
	\caption{LineMOD: Object recall (ADD \cite{hinterstoisser2012model} metric) of methods that use different amounts of training and test data, results taken from \cite{tekin2017real}}
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{r|cc|ccccccc|ccc}
			
			Test data&\multicolumn{9}{c}{RGB}& \multicolumn{3}{|c}{$\qquad$ +Depth (ICP)$\qquad$}\\
			\toprule
			Train data&\multicolumn{2}{c|}{RGB w/o real pose labels}& \multicolumn{7}{c}{RGB with real pose labels} & \multicolumn{2}{|c}{--}\\
			\toprule
			Object &\citeauthor{kehl2017ssd} & OURS & \multicolumn{2}{c}{\citeauthor{brachmann2016uncertainty}} & \multicolumn{2}{c}{\citeauthor{rad2017bb8}} &\citeauthor{tekin2017real} & \multicolumn{2}{c|}{\citeauthor{xiang2017posecnn}} & OURS & \citeauthor{kehl2017ssd} \\
			\toprule
			&&&& +refine && +refine &&& +DeepIm \\
			\midrule
			Ape & 0.00 &   \textbf{4.18} &      -& 	33.2& 27.9& 40.4& 21.62            & -& \textbf{77.0} & 24.35 &\textbf{65}\\
			Benchvise &  0.18 &\textbf{22.85}&  -& 	64.8& 62.0& 91.8& 81.80   & -& \textbf{97.5} & \textbf{89.13}&80\\
			Cam &0.41 & \textbf{32.91}&         -& 	38.4& 40.1& 55.7& 36.57            & -& \textbf{93.5} & \textbf{82.10}&78\\
			Can & 1.35 &   \textbf{37.03}&      -& 	62.9& 48.1& 64.1& 68.80   & -& \textbf{96.5} & 70.82&\textbf{86}\\
			Cat &  0.51 & \textbf{18.68}&       -& 	42.7& 45.2& 62.6& 41.82            & -& \textbf{82.1} & \textbf{72.18}&70\\
			Driller &  2.58 & \textbf{24.81}&   -& 	61.9& 58.6& 74.4& 63.51   & -& \textbf{95.0} & 44.87&\textbf{73}\\
			Duck & 0.00 & \textbf{5.86}&        -& 	30.2& 32.8& 44.3& 27.23            & -& \textbf{77.7} & 54.63 &\textbf{66}\\
			Eggbox & 8.90 & \textbf{81.00}&     -& 	49.9& 40.0& 57.8& 69.58   & -& \textbf{97.1} & 96.62&\textbf{100}\\
			Glue&0.00  & \textbf{46.17}&        -& 	31.2& 27.0& 41.2& 80.02   & -& \textbf{99.4} & 94.18&\textbf{100}\\
			Holepuncher & 0.30 &\textbf{18.20}& -& 	52.8& 42.4& \textbf{67.2}& 42.63   & -& 52.8 & \textbf{51.25}&49\\
			Iron & 8.86 &\textbf{35.05} &       -& 	80.0& 67.0& 84.7& 74.97   & -& \textbf{98.3} & \textbf{77.86}&\textbf{78}\\
			Lamp & 8.2 & \textbf{61.15} &       -& 	67.0& 39.9& 76.5& 71.11   & -& \textbf{97.5} & \textbf{86.31}&73\\
			Phone & 0.18 &\textbf{36.27} &      -& 	38.1& 35.2& 54.0& 47.74   & -& \textbf{87.7} & \textbf{86.24}&79\\
			\midrule
			Mean &  2.42& \textbf{32.63}  & 32.3   & 50.2 & 43.6& 62.7 & 55.95  & 62.7 & \textbf{88.6} & 71.58 & \textbf{79}
		\end{tabular}
	\end{adjustbox}
	\label{tab:linemod}
\end{table*}



\begin{figure*}
	\captionsetup{width=0.8\textwidth}
	\subfloat[Object 5, one view-dependent symmetry]{
		\begin{minipage}[t]{0.5\columnwidth}
			\input{obj5_bbest_R_err_hist2.tex}
			\input{obj5_bbest_t_err_hist2.tex}
		\end{minipage}%
		\begin{minipage}[t]{0.5\columnwidth}
			\input{obj5_bbest_icp_R_err_hist2.tex}
			\input{obj5_bbest_icp_t_err_hist2.tex}
	\end{minipage}}%
	\subfloat[Object 28, two view-dependent symmetries]{
		\begin{minipage}[t]{0.5\columnwidth}
			\input{obj28_bbest_R_err_hist2.tex}
			\input{obj28_bbest_t_err_hist2.tex}
		\end{minipage}%
		\begin{minipage}[t]{0.5\columnwidth}
			\input{obj28_bbest_icp_R_err_hist2.tex}
			\input{obj28_bbest_icp_t_err_hist2.tex}
	\end{minipage}}
	\caption{Rotation and translation error histograms on all T-LESS test scenes with our RGB-based (left columns) and ICP-refined (right columns) 6D Object Detection }
	\label{fig:histo}
\end{figure*}
\begin{figure*}[t]%tbp]
	\centering
	\subfloat[]{{\includegraphics[width=0.31\linewidth]{tless_15_nodetect.jpeg} }}%
	\subfloat[]{{\includegraphics[width=0.31\linewidth]{linemod_occl.jpeg} }}%
	\subfloat[]{{\includegraphics[width=0.31\linewidth]{tless_occl.jpeg} }}
	\caption{Failure cases; Blue: True poses; Green: Predictions; (a) Failed detections due to occlusions and object ambiguity, (b) failed AAE predictions of Glue (middle) and Eggbox (right) due to strong occlusion, (c) inaccurate predictions due to occlusion}
	\label{fig:failures}%
\end{figure*}
	\subsection{Discussion of 6D Object Detection results}
	Our RGB-only 6D Object Detection pipeline consists of 2D detection, 3D orientation estimation, projective distance estimation and perspective error correction. Although the results are visually appealing, to reach the performance of state-of-the-art depth-based methods we also need to refine our estimates using a depth-based \gls{ICP}. 
	Table \ref{tab:tless} presents our 6D detection evaluation on all scenes of the T-LESS dataset, which contains a high amount of pose ambiguities. Our pipeline outperforms all 15 reported T-LESS results on the 2018 BOP benchmark from \cite{hodan2018bop} in a fraction of the runtime. Table \ref{tab:tless} shows an extract of competing methods. Our RGB-only results can compete with the RGB-D learning-based approaches of \cite{brachmann2016uncertainty} and \cite{kehl2016deep}. Previous state-of-the-art approaches from \cite{vidal20186d,drost2010model} perform a time consuming refinement search through multiple pose hypotheses while we only perform the ICP on a single pose hypothesis. That being said, the codebook is well suited to generate multiple hypotheses using $k>1$ nearest neighbors. The right part of Table \ref{tab:tless} shows results with ground truth bounding boxes yielding an upper bound on the pose estimation performance.
	
	The results in Table \ref{tab:tless} show that our domain randomization strategy allows to generalize from 3D reconstructions as well as untextured CAD models as long as the considered objects are not significantly textured. Instead of a performance drop we report an increased \gls{VSD}$<0.3$ recall due to the more accurate geometry of the model which results in correct bounding box diagonals and thus a better projective distance estimation in the RGB-domain.
	
	In Table \ref{tab:linemod} we also compare our pipeline against state-of-the-art methods on the LineMOD dataset. Here, our synthetically trained pipeline does not reach the performance of approaches that use real pose annotated training data. 
	
	
	There are multiple issues: (1) As described in Sec \ref{sec:cond} the real training and test set are strongly correlated and approaches using the real training set can over-fit to it; (2) the models provided in LineMOD are quite bad which affects both, the detection and pose estimation performance of synthetically trained approaches; (3) the advantage of not suffering from pose-ambiguities does not matter much in LineMOD where most object views are pose-ambiguity free; (4) We train and test poses from the whole SO(3) as opposed to only a limited range in which the test poses lie.
	SSD6D also trains only on synthetic views of the 3D models and we outperform their approach by a big margin in the RGB-only domain before \gls{ICP} refinement. 
	
	\subsection{Failure Cases}
	Figure \ref{fig:failures} shows qualitative failure cases, mostly stemming from missed detections and strong occlusions. A weak point is the dependence on the bounding box size at test time to predict the object distance. Specifically, under sever occlusions the predicted bounding box tends to shrink such that it does not encompass the occluded parts of the detected object even if it is trained to do so.
	If the usage of depth data is clear in advance other methods for directly using depth-based methods for distance estimation might be better suited. Furthermore, on strongly textured objects, the AAEs should not be trained without rendering the texture since otherwise the texture might not be distinguishable from shape at test time. The sim2real transfer on strongly reflective objects like satellites can be challenging and might require physically-based renderings.
	Some objects, like long, thin pens can fail because their tight object crops at training and test time appear very near from some views and very far from other views, thus hindering the learning of proper pose representations. As the object size is unknown during test time, we cannot simply crop a constantly sized area. 
	

\begin{figure}[t]%tbp
	\centering
	\captionsetup{width=0.99\columnwidth}
	\includegraphics[width=0.9\columnwidth]{ECCV-live-demo.png}
	\caption{MobileNetSSD and \glspl{AAE} on T-LESS objects, demonstrated live at ECCV 2018 on a Jetson TX2}
	\label{fig:ECCV-live-demo}
\end{figure}

	\subsection{Rotation and Translation Histograms}
	
	To investigate the effect of \gls{ICP} and to obtain an intuition about the pose errors, we plot the rotation and translation error histograms of two T-LESS objects (Fig. \ref{fig:histo}). We can see the view-dependent symmetry axes of both objects in the rotation errors histograms. We also observe that the translation error is strongly improved through the depth-based ICP while the rotation estimates from the \gls{AAE} are hardly refined. Especially when objects are partly occluded, the bounding boxes can become inaccurate and the projective distance estimation (Sec. \ref{sec:proj}) fails to produce very accurate distance predictions. Still, our global and fast 6D Object Detection provides sufficient accuracy for an iterative local refinement method to reliably converge.
	
	\subsection{Demonstration on Embedded Hardware}
	
	The presented \glspl{AAE} were also ported onto a Nvidia Jetson TX2 board, together with a small footprint MobileNet from \cite{howard2017mobilenets} for the bounding box detection. A webcam was connected, and this setup was demonstrated live at ECCV 2018, both in the demo session and during the oral presentation. For this demo we acquired several of the T-LESS objects. As can be seen in Figure~\ref{fig:ECCV-live-demo}, lighting conditions were dramatically different than in the test sequences from the T-LESS dataset which validates the robustness and applicability of our approach outside lab conditions. No ICP was used, so the errors in depth resulting from the scaling errors of the MobileNet, were not corrected. However, since small errors along the depth direction are less perceptible for humans, our approach could be interesting for augmented reality applications. The detection, pose estimation and visualization of the three test objects ran at over 13Hz.
	
	\section{Conclusion}
	We have proposed a new self-supervised training strategy for Autoencoder architectures that enables robust 3D object orientation estimation on various RGB sensors while training only on synthetic views of a 3D model. By demanding the Autoencoder to revert geometric and color input augmentations, we learn representations that (1) specifically encode 3D object orientations, (2) are invariant to a significant domain gap between synthetic and real RGB images, (3) inherently regard pose ambiguities from symmetric object views. Around this approach, we created a real-time (42 fps), RGB-based pipeline for 6D object detection which is especially suitable when pose-annotated RGB sensor data is not available.
	
	
	
	\section*{Acknowledgement}
	We would like to thank Dr. Ingo Kossyk, Dimitri Henkel and Max Denninger for helpful discussions. We also thank the reviewers for their useful comments. This work has been partly funded by Robert Bosch GmbH, Corporate Research.


\bibliographystyle{spbasic}      % basic style, author-year citations
%\bibliographystyle{spmpsci}      % mathematics and physical sciences
%\bibliographystyle{spphys}       % APS-like style for physics
\bibliography{refs}   % name your BibTeX data base

\end{document}
% end of file template.tex

