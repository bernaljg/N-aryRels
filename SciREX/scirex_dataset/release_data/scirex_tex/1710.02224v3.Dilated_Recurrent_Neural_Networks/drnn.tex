\documentclass{article}

% if you need to pass options to natbib, use, e.g.:
% \PassOptionsToPackage{numbers, compress}{natbib}
% before loading nips_2017
%
% to avoid loading the natbib package, add option nonatbib:
% \usepackage[nonatbib]{nips_2017}

% \usepackage{nips_2017}

% to compile a camera-ready version, add the [final] option, e.g.:
\usepackage[final]{nips_2017}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{color}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{dutchcal}
\usepackage{tablefootnote}
\usepackage{verbatim} 

\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\DeclareMathOperator*{\argmin}{argmin}

\definecolor{orange}{rgb}{1,0.5,0}
\newcommand{\algname}{\textsc{DilatedRNN }}
\newcommand{\algnamens}{\textsc{DilatedRNN}}
\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}

\title{Dilated Recurrent Neural Networks}

% The \author macro works with any number of authors. There are two
% commands used to separate the names and addresses of multiple
% authors: \And and \AND.
%
% Using \And between authors leaves it to LaTeX to determine where to
% break the lines. Using \AND forces a line break at that point. So,
% if LaTeX puts 3 of 4 authors names on the first line, and the last
% on the second line, try using \AND instead of \And before the third
% author name.


\setcounter{footnote}{0}
\author{
  Shiyu Chang$^1$\thanks{Denotes equal contribution.}, Yang Zhang$^1$\samethanks, Wei Han$^2$\samethanks, Mo Yu$^1$, Xiaoxiao Guo$^1$, Wei Tan$^1$, \\
  {\bf Xiaodong Cui$^1$, Michael Witbrock$^1$, Mark Hasegawa-Johnson$^2$, Thomas S. Huang$^2$}\\
  $^1$IBM Thomas J. Watson Research Center, Yorktown, NY 10598, USA\\
  $^2$University of Illinois at Urbana-Champaign, Urbana, IL 61801, USA \\
  \texttt{\{shiyu.chang, yang.zhang2, xiaoxiao.guo\}@ibm.com}, \\
  \texttt{\{yum, wtan, cuix, witbrock\}@us.ibm.com},\\ 
  \texttt{\{weihan3, jhasegaw, t-huang1\}@illinois.edu}
}
\begin{document}
% \nipsfinalcopy is no longer used

\maketitle
\setcounter{footnote}{0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Learning with recurrent neural networks (RNNs) on long sequences is a notoriously difficult task.  There are three major challenges: 1) complex dependencies, 2) vanishing and exploding gradients, and 3) efficient parallelization. In this paper, we introduce a simple yet effective RNN connection structure, the \algnamens, which simultaneously tackles all of these challenges.  The proposed architecture is characterized by multi-resolution {\bf dilated recurrent skip connections}, and can be combined flexibly with diverse RNN cells.  Moreover, the \algname reduces the number of parameters needed and enhances training efficiency significantly, while matching state-of-the-art performance (even with standard RNN cells) in tasks involving very long-term dependencies.  To provide a theory-based quantification of the architecture's advantages, we introduce a memory capacity measure, the {\bf mean recurrent length}, which is more suitable for RNNs with long skip connections than existing measures.  We rigorously prove the advantages of the \algname over other recurrent neural architectures.  The code for our method is publicly available\footnote{\url{https://github.com/code-terminator/DilatedRNN}}.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sect:intro}
Recurrent neural networks (RNNs) have been shown to have remarkable performance on many sequential learning problems.  However, long sequence learning with RNNs remains a challenging problem for the following reasons:  first, memorizing extremely long-term dependencies while maintaining mid- and short-term memory is difficult;  second, training RNNs using back-propagation-through-time is impeded by vanishing and exploding gradients; And lastly, both forward- and back-propagation are performed in a sequential manner, which makes the training time-consuming.  

Many attempts have been made to overcome these difficulties using specialized neural structures, cells, and optimization techniques. Long short-term memory (LSTM) \cite{hochreiter1997long} and gated recurrent units (GRU) \cite{chung2014empirical} powerfully model complex data dependencies. Recent attempts have focused on multi-timescale designs, including clockwork RNNs \cite{koutnik2014clockwork}, phased LSTM \cite{Neil2016phased}, hierarchical multi-scale RNNs \cite{chung2016hierarchical}, {\em etc.} The problem of vanishing and exploding gradients is mitigated by LSTM and GRU memory gates; other partial solutions include gradient clipping \cite{pascanu2013difficulty}, orthogonal and unitary weight optimization \cite{arjovsky2016unitary, le2015simple, wisdom2016full}, and skip connections across multiple timestamps \cite{el1995hierarchical, zhang2016architectural}.  For efficient sequential training, WaveNet \cite{van2016wavenet} abandoned RNN structures, proposing instead the dilated causal convolutional neural network (CNN) architecture, which provides significant advantages in working directly with raw audio waveforms.  However, the length of dependencies captured by a dilated CNN is limited by its kernel size, whereas an RNN's autoregressive modeling can, in theory, capture potentially infinitely long dependencies with a small number of parameters.  Recently, Yu {\em et al.} \cite{yu2017learning} proposed learning-based RNNs with the ability to jump (skim input text) after seeing a few timestamps worth of data; although the authors showed that the modified LSTM with jumping provides up to a six-fold speed increase, the efficiency gain is mainly in the testing phase. 

In this paper, we introduce the \algnamens, a neural connection architecture analogous to the dilated CNN \cite{van2016wavenet, yu2015multi}, but under a recurrent setting.  Our approach provides a simple yet useful solution that tries to alleviate all challenges simultaneously.  The \algname is a multi-layer, and cell-independent architecture characterized by multi-resolution {\bf dilated recurrent skip connections}.  The main contributions of this work are as follows.  1) We introduce a new dilated recurrent skip connection as the key building block of the proposed architecture.  These alleviate gradient problems and extend the range of temporal dependencies like conventional recurrent skip connections, but in the dilated version require fewer parameters and significantly enhance computational efficiency.  2) We stack multiple dilated recurrent layers with hierarchical dilations to construct a \algnamens, which learns temporal dependencies of different scales at different layers.  3) We present the {\bf mean recurrent length} as a new neural memory capacity measure that reveals the performance difference between the previously developed recurrent skip-connections and the dilated version.  We also verify the optimality of the exponentially increasing dilation distribution used in the proposed architecture.  It is worth mentioning that,  the recent proposed Dilated LSTM \cite{vezhnevets2017feudal} can be viewed as a special case of our model, which contains only one dilated recurrent layer with fixed dilation.  The main purpose of their model is to reduce the temporal resolution on time-sensitive tasks.  Thus, the Dilated LSTM is not a general solution for modeling at multiple temporal resolutions.

We empirically validate the \algname in multiple RNN settings on a variety of sequential learning tasks, including long-term memorization, pixel-by-pixel classification of handwritten digits (with permutation and noise), character-level language modeling, and speaker identification with raw audio waveforms.  The \algname improves significantly on the performance of a regular RNN, LSTM, or GRU with far fewer parameters.  Many studies \cite{chung2014empirical, le2015simple} have shown that vanilla RNN cells perform poorly in these learning tasks.  However, within the proposed structure, even vanilla RNN cells outperform more sophisticated designs, and match the state-of-the-art.  We believe that the \algname provides a simple and generic approach to learning on very long sequences.

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{./figure/drnn_illustration.pdf}
  \vspace*{-0.2in}
  \caption{(left) A single-layer RNN with recurrent skip connections. (mid) A single-layer RNN with dilated recurrent skip connections. (right) A computation structure equivalent to the second graph, which reduces the sequence length by four times.}
  \label{fig:skip-dilated-comparision}
  \vspace*{-0.15in}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dilated Recurrent Neural Networks}
\label{sect:drnn}
The main ingredients of the \algname are its dilated recurrent skip connection and its use of exponentially increasing dilation; these will be discussed in the following two subsections respectively.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dilated Recurrent Skip Connection}
\label{subsec:dilated_skip}

Denote {\small$c_t^{(l)}$} as the cell in layer $l$ at time $t$. The dilated skip connection can be represented as
\begin{equation}
\small
c_t^{(l)} = f \left( x_t^{(l)}, c_{t-s^{(l)}}^{(l)} \right).
\label{eq:dilated_skip}
\end{equation}
This is similar to the regular skip connection\cite{el1995hierarchical, zhang2016architectural}, which can be represented as
\begin{equation}
\small
c_t^{(l)} = f \left( x_t^{(l)}, c_{t-1}^{(l)}, c_{t-s^{(l)}}^{(l)} \right).
\label{eq:rnn}
\end{equation}
{\small$s^{(l)}$} is referred to as the skip length, or dilation of layer $l$; {\small$x_t^{(l)}$} as the input to layer $l$ at time $t$; and $f(\cdot)$ denotes any RNN cell and output operations, \emph{e.g.} Vanilla RNN cell, LSTM, GRU {\em etc.}  Both skip connections allow information to travel along fewer edges. The difference between dilated and regular skip connection is that the dependency on {\small$c_{t-1}^{(l)}$} is removed in dilated skip connection. The left and middle graphs in figure \ref{fig:skip-dilated-comparision} illustrate the differences between two architectures with dilation or skip length {\small$s^{(l)} = 4$}, where $W'_r$ is removed in the middle graph. This reduces the number of parameters.  

More importantly, computational efficiency of a parallel implementation (\emph{e.g.}, using GPUs) can be greatly improved by parallelizing operations that, in a regular RNN, would be impossible. The middle and right graphs in figure \ref{fig:skip-dilated-comparision} illustrate the idea with {\small$s^{(l)} = 4$} as an example. The input subsequences {\small$\{ x_{4t}^{(l)} \}$}, {\small$\{ x_{4t+1}^{(l)} \}$}, {\small$\{ x_{4t+2}^{(l)} \}$} and {\small$\{ x_{4t+3}^{(l)} \}$} are given four different colors. The four cell chains, {\small$\{ c_{4t}^{(l)} \}$}, {\small$\{ c_{4t+1}^{(l)} \}$}, {\small$\{ c_{4t+2}^{(l)} \}$} and {\small$\{ c_{4t+3}^{(l)} \}$}, can be computed in parallel by feeding the four subsequences into a regular RNN, as shown in the right of figure \ref{fig:skip-dilated-comparision}. The output can then be obtained by interweaving among the four output chains. The degree of parallelization is increased by {\small$s^{(l)}$} times.  


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Exponentially Increasing Dilation}

\begin{figure}[t]
  \centering
  \includegraphics[width=1\textwidth]{./figure/combined_drnn.pdf}
  \vspace*{-0.15in}
  \caption{(left) An example of a three-layer \algname with dilation 1, 2, and 4. (right) An example of a two-layer \algnamens, with dilation 2 in the first layer. In such a case, extra embedding connections are required (red arrows) to compensate missing data dependencies.}
  \label{fig:drnn_example}
  \vspace*{-0.15in}
\end{figure}

To extract complex data dependencies, we stack dilated recurrent layers to construct \algnamens.  Similar to settings that were introduced in WaveNet \cite{van2016wavenet}, the dilation increases exponentially across layers. Denote {\small$s^{(l)}$} as the dilation of the $l$-th layer. Then,
\begin{equation}
\small
s^{(l)} = M^{l-1}, l = 1, \cdots, L.
\label{eq:skip_distribution}
\end{equation}
The left side of figure \ref{fig:drnn_example} depicts an example of \algname with $L=3$ and $M = 2$.  On one hand,  stacking multiple dilated recurrent layers increases the model capacity.  On the other hand, exponentially increasing dilation brings two benefits. First, it makes different layers focus on different temporal resolutions.  Second, it reduces the average length of paths between nodes at different timestamps, which improves the ability of RNNs to extract long-term dependencies and prevents vanishing and exploding gradients.  A formal proof of this statement will be given in section \ref{sect:complexity}.

To improve overall computational efficiency, a generalization of our standard \algname is also proposed. The dilation in the generalized \algname does not start at one, but {\small$M^{l_0}$}.  Formally,
\begin{equation}
\small
s^{(l)} = M^{(l-1+l_0)}, l = 1, \cdots, L \text{ and } l_0 \ge 0, 
\label{eq:drnn_general}
\end{equation}
where {\small$M^l_0$} is called the starting dilation. To compensate for the missing dependencies shorter than {\small$M^{l_0}$}, a 1-by-{\small$M^{(l_0)}$} convolutional layer is appended as the final layer. 
 The right side of figure \ref{fig:drnn_example} illustrates an example of $l_0 = 1$, \emph{i.e.} dilations start at two.  Without the red edges, there would be no edges connecting nodes at odd and even time stamps. As discussed in section \ref{subsec:dilated_skip}, the computational efficiency can be increased by {\small$M^{l_0}$} by breaking the input sequence into {\small$M^{l_0}$} downsampled subsequences, and feeding each into a $L-l_0$-layer regular \algname with shared weights. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Memory Capacity of \algname}
\label{sect:complexity}
In this section, we extend the analysis framework in \cite{zhang2016architectural} to establish better measures of memory capacity and parameter efficiency, which will be discussed in the following two sections respectively.

\subsection{Memory Capacity}
\label{subsec:mem_cap}
To facilitate theoretical analysis, we apply the cyclic graph $\mathcal{G}_c$ notation introduced in \cite{zhang2016architectural}.

\begin{definition}[Cyclic Graph]
The cyclic graph representation of an RNN structure is a directed multi-graph, $\mathcal{G}_C = (V_C, E_C)$. Each edge is labeled as $e = (u, v, \sigma)\in E_C$, where $u$ is the origin node, $v$ is the destination node, and $\sigma$ is the number of time steps the edge travels. Each node is labeled as $v = (i, p) \in V_C$, where $i$ is the time index of the node modulo $m$, $m$ is the period of the graph, and $p$ is the node index. $\mathcal{G}_C$ must contain at least one directed cycle. Along the edges of any directed cycle, the summation of $\sigma$ must not be zero.
\end{definition}

Define $\mathcal{d}_i(n)$ as the length of the shortest path from any input node at time $i$ to any output node at time $i+n$. In \cite{zhang2016architectural}, a measure of the memory capacity is proposed that essentially only looks at $\mathcal{d}_i(m)$, where $m$ is the period of the graph. This is reasonable when the period is small. However, when the period is large, the entire distribution of $\mathcal{d}_i (n), \forall n \leq m$ makes a difference, not just the one at span $m$.  As a concrete example, suppose there is an RNN architecture of period $m = 10,000$, implemented using equation \eqref{eq:rnn} with skip length $s^{(l)}=m$, so that $\mathcal{d}_i(n) = n$ for $n = 1, \cdots, 9,999$ and $\mathcal{d}_i(m) = 1$. This network rapidly memorizes the dependence on inputs at time $i$ of the outputs at time $i+m=i+10,000$, but shorter dependencies $2\le n\le 9,999$ are much harder to learn.  Motivated by this, we proposed the following additional measure of memory capacity.
\begin{definition}[Mean Recurrent Length]
  For an RNN with cycle $m$, the mean recurrent length is
\begin{equation}
\small
\bar{\mathcal{d}} = \frac{1}{m} \sum_{n=1}^m \max_{i \in V} \mathcal{d}_i(n).
\label{eq:recur_len}
\end{equation}
\end{definition}
Mean recurrent length studies the average dilation across different time spans within a cycle. An architecture with good memory capacity should generally have a small recurrent length for all time spans. Otherwise the network can only selectively memorize information at a few time spans. Also, we take the maximum over $i$, so as to punish networks that have good length only for a few starting times, which can only well memorize information originating from those specific times.  The proposed mean recurrent length has an interesting reciprocal relation with the short-term memory (STM) measure proposed in \cite{jaeger2001short}, but mean recurrent length emphasizes more on long-term memory capacity, which is more suitable for our intended applications.

With this, we are ready to illustrate the memory advantage of \algname. Consider two RNN architectures. One is the proposed \algname structure with $d$ layers and $M = 2$ (equation \eqref{eq:dilated_skip}). The other is a regular $d$-layer RNN with skip connections (equation \eqref{eq:rnn}).  If the skip connections are of skip $s^{(l)}=2^{l-1}$, then connections in the RNN are a strict superset of those in the \algname, and the RNN accomplishes exactly the same $\bar{\mathcal{d}}$ as the \algname, but with twice the number of trainable parameters (see section \ref{sec:efficiency}).  Suppose one were to give every layer in the RNN the largest possible skip for any graph with a period of $m=2^{d-1}$: set $s^{(l)}=2^{d-1}$ in every layer, which is the regular skip RNN setting.  This apparent advantage turns out to be a disadvantage, because time spans of $2\le n<m$ suffer from increased path lengths, and therefore 
\begin{equation}
\small
\bar{\mathcal{d}} = (m-1)/2 + \log_2{m} + 1/m + 1,
\end{equation}
which grows linearly with $m$. On the other hand, for the proposed \algnamens, 
\begin{equation}
\small
\bar{\mathcal{d}} = (3m-1)/2m \log_2 m + 1/m + 1,
\end{equation}
where $\bar{\mathcal{d}}$ only grows logarithmically with $m$, which is much smaller than that of regular skip RNN. It implies that the information in the past on average travels along much fewer edges, and thus undergoes far less attenuation.  The derivation is given in appendix \ref{appendix:mean_recurrent_length} in the supplementary materials.

\subsection{Parameter Efficiency}
\label{sec:efficiency}

The advantage of \algname lies not only in the memory capacity but also the number of parameters that achieves such memory capacity. To quantify the analysis, the following measure is introduced.
\begin{definition}[Number of Recurrent Edges per Node]
Denote Card$\{\cdot\}$ as the set cardinality. For an RNN represented as $\mathcal{G}_C = (V_C, E_C)$, the number of recurrent edges per node, $N_r$, is defined as
\begin{equation}
\small
N_r = \mbox{Card}\left\{ e = (u,v,\sigma) \in E_C: \sigma \neq 0 \right\} / ~\mbox{Card} \{V_C\}.
\end{equation}
\end{definition}

Ideally, we would want a network that has large recurrent skips while maintaining a small number of recurrent weights. It is easy to show that $N_r$ for \algname is 1 and that for RNNs with regular skip connections is 2. The \algname has half the recurrent complexity as the RNN with regular skip RNN because of the removal of the direct recurrent edge.  The following theorem states that the \algname is able to achieve the best memory capacity among a class of connection structures with $N_r = 1$, and thus is among the most parameter efficient RNN architectures.
\begin{theorem}[Parameter Efficiency of \algnamens]
Consider a subset of $d$-layer RNNs with period $m = M^{d-1}$ that consists purely of dilated skip connections (hence $N_r = 1$). For the RNNs in this subset, there are $d$ different dilations, $1=s_1 \leq s_2 \leq \cdots \leq s_d=m$, and
\begin{equation}
\small
s_i = n_i s_{i-1},
\label{eq:skip_ratio}
\end{equation}
where $n_i$ is any arbitrary positive integer. Among this subset, the $d$-layer \algname with dilation rate $\{M^0, \cdots, M^{d-1}\}$ achieves the smallest $\bar{\mathcal{d}}$.
\label{thm:efficiency}
\end{theorem}
The proof is motivated by \cite{caianiello1982systemic}, and is given in appendix \ref{appendix:optimality}.

\subsection{Comparing with Dilated CNN}
\label{subsec:compare_CNN}

Since \algname is motivated by dilated CNN \cite{van2016wavenet, yu2015multi}, it is useful to compare their memory capacities.  Although cyclic graph, mean recurrent length and number of recurrent edges per node are designed for recurrent structures, they happen to be applicable to dilated CNN as well.  What's more, it can be easily shown that, compared to a \algname with the same number of layers and dilation rate of each layer, a dilated CNN has exactly the same number of recurrent edges per node, and a slightly smaller (by $\log_2 m$) mean recurrent length. Hence both architectures have the same model complexity, and it looks like a dilated CNN has a slightly better memory capacity.

However, mean recurrent length only measures the memory capacity \emph{within} a cycle. When going \emph{beyond} a cycle, it is already shown that the recurrent length grows linearly with the number of cycles \cite{zhang2016architectural} for RNN structures, including \algnamens, whereas for a dilated CNN, the receptive field size is always finite (thus mean recurrent length goes to infinity beyond the receptive field size).  For example, with dilation rate $M = 2^{l-1}$ and $d$ layers $l = 1, \cdots, d$, a dilated CNN has a receptive field size of $2^d$, which is two cycles.  On the other hand, the memory of a \algname can go far beyond two cycles, particularly with the sophisticated units like GRU and LSTM. Hence the memory capacity advantage of \algname over a dilated CNN is obvious.

\subsection{Comparing with Clockwork RNN}
\label{subsec:compare_CWRNN}

Clockwork RNN \cite{koutnik2014clockwork} also utilizes the exponentially decreasing temporal resolutions to strengthen its memory capacity, but in a different way. Clockwork RNN controls the update rate of each hidden node, whereas \algname updates all the nodes at each time step, but controls the data dependency. As a result, the memory capacity of the Clockwork RNN is undesirably time-dependent -- at some output times, \emph{e.g.} exponentials of 2, the output node has short shortest paths connecting to the input nodes in the past, matching the case of \algnamens; at other times, the recurrent paths can be much longer. Since mean recurrent length penalizes such time-variant memory capacity by taking the worst case over the absolute times, a \algname has a much better mean recurrent length than a Clockwork RNN with number of groups matching the number of layers in the \algnamens.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experiments}
\label{sect:exp}
In this section, we evaluate the performance of \algname on four different tasks, which include long-term memorization, pixel-by-pixel MNIST classification \cite{lecun1998gradient}, character-level language modeling on the Penn Treebank \cite{marcus1993building}, and speaker identification with raw waveforms on VCTK \cite{yamagishi2012vctk}. We also investigate the effect of dilation on performance and computational efficiency.

Unless specified otherwise, all the models are implemented with Tensorflow \cite{abadi2016tensorflow}.  We use the default nonlinearities and RMSProp optimizer \cite{tieleman2012lecture} with learning rate 0.001 and decay rate of 0.9.  All weight matrices are initialized by the standard normal distribution.  The batch size is set to 128.   Furthermore, in all the experiments, we apply the sequence classification setting \cite{xing2010brief}, where the output layer only adds at the end of the sequence.  Results are reported for trained models that achieve the best validation loss.   Unless stated otherwise, no tricks, such as gradient clipping \cite{pascanu2013difficulty}, learning rate annealing, recurrent weight dropout \cite{semeniuta2016recurrent}, recurrent batch norm \cite{semeniuta2016recurrent}, layer norm \cite{ba2016layer}, {\em etc.}, are applied. All the tasks are sequence level classification tasks, and therefore the ``gridding'' problem \cite{yu2017dilated} is irrelevant. No ``degridded'' module is needed.

Three RNN cells, Vanilla, LSTM and GRU cells, are combined with the \algname, which we refer to as dilated Vanilla, dilated LSTM and dilated GRU, respectively.  The common baselines include single-layer RNNs (denoted as Vanilla RNN, LSTM, and GRU), multi-layer RNNs (denoted as stack Vanilla, stack LSTM, and stack GRU), and Vanilla RNN with regular skip connections (denoted as Skip Vanilla). Additional baselines will be specified in the corresponding subsections.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Copy memory problem}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\textwidth]{./figure/memcopy_combine.png}
  \vspace*{-0.1in}
  \caption{Results of the copy memory problem with $T=500$ (left) and $T=1000$ (right). The dilated-RNN converges quickly to the perfect solutions.  Except for RNNs with dilated skip connections, all other methods are unable to improve over random guesses.}
  \label{fig:memcopy}
  \vspace*{-0.15in}
\end{figure}

This task tests the ability of recurrent models in memorizing long-term information.  We follow a similar setup in \cite{arjovsky2016unitary, wisdom2016full, hochreiter1997long}.  Each input sequence is of length $T + 20$. The first ten values are randomly generated from integers 0 to 7;  the next $T - 1$ values are all 8; the last 11 values are all 9, where the first 9 signals that the model needs to start to output the first 10 values of the inputs.   Different from the settings in \cite{arjovsky2016unitary, wisdom2016full}, the average cross-entropy loss is only measured at the last 10 timestamps.  Therefore, the random guess yields an expected average cross entropy of $\ln(8) \approx 2.079$.  The \algname uses 9 layers with hidden state size of 10.  The dilation starts from one to 256 at the last hidden layer.  The single-layer baselines have 256 hidden units. The multi-layer baselines use the same number of layers and hidden state size as the \algname.  The skip Vanilla has 9 layers, and the skip length at each layer is 256,  which matches the maximum dilation of the \algnamens.  

The convergence curves in two settings, $T = 500$ and $1,000$, are shown in figure \ref{fig:memcopy}.  In both settings, the \algname with vanilla cells converges to a good optimum after about 1,000 training iterations, whereas dilated LSTM and GRU converge slower.  It might be because the LSTM and GRU cells are much more complex than the vanilla unit.  Except for the proposed models, all the other models are unable to do better than the random guess, including the skip Vanilla.  These results suggest that the proposed structure as a simple renovation is very useful for problems requiring very long memory.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pixel-by-pixel MNIST}
Sequential classification on the MNIST digits \cite{lecun1998gradient} is commonly used to test the performance of RNNs.  We first implement two settings. In the first setting, called the unpermuted setting, we follow the same setups in \cite{arjovsky2016unitary, krueger2016zoneout, le2015simple, wisdom2016full, zhang2016architectural} by serializing each image into a 784 x 1 sequence.  The second setting, called permuted setting, rearranges the input sequence with a fixed permutations.  Training, validation and testing sets are the default ones in Tensorflow.  Hyperparameters and results are reported in table \ref{table:pxiel-mnist}.  In addition to the baselines already described, we also implement the dilated CNN.  However, the receptive fields size of a nine-layer dilated CNN is 512, and is insufficient to cover the sequence length of 784. Therefore, we added one more layer to the dilated CNN, which enlarges its receptive field size to 1,024.  It also forms a slight advantage of dilated CNN over the \algname structures. 

In the unpermuted setting, the dilated GRU achieves the best evaluation accuracy of 99.2.  However, the performance improvements of dilated GRU and LSTM over both the single- and multi-layer ones are marginal, which might be because the task is too simple.   Further, we observe significant performance differences between stack Vanilla and skip vanilla, which is consistent with the findings in \cite{zhang2016architectural} that RNNs can better model long-term dependencies and achieves good results when recurrent skip connections added.  Nevertheless, the dilated vanilla has yet another significant performance gain over the skip Vanilla, which is consistent with our argument in section \ref{sect:complexity}, that the \algname has a much more balanced memory over a wide range of time periods than RNNs with the regular skips. The performance of the dilated CNN is dominated by dilated LSTM and GRU, even when the latter have fewer parameters (in the 20 hidden units case) than the former (in the 50 hidden units case).

In the permuted setting, almost all performances are lower.  However, the \algname models maintain very high evaluation accuracies.  In particular, dilated Vanilla outperforms the previous RNN-based state-of-the-art Zoneout \cite{krueger2016zoneout} with a comparable number of parameters.  It achieves test accuracy of 96.1 with only 44k parameters.  Note that the previous state-of-the-art utilizes the recurrent batch normalization.  The version without it has a much lower performance compared to all the dilated models. We believe the consistently high performance of the \algname across different permutations is due to its hierarchical multi-resolution dilations.   In addition, the dilated CNN is able the achieve the best performance, which is in accordance with our claim in section \ref{subsec:compare_CNN} that dilated CNN has a slightly shorter mean recurrent length than \algname architectures, when sequence length fall within its receptive field size.  However, note that this is achieved by adding one additional layer to expand its receptive field size compared to the RNN counterparts. When the useful information lies outside its receptive field, the dilated CNN might fail completely.

In addition to these two settings, we propose a more challenging task called the noisy MNIST, where we pad the unpermuted pixel sequences with $[0, 1]$ uniform random noise to the length of $T$.  The results with two setups $T=1,000$ and $T=2,000$ are shown in figure \ref{fig:noisy_1000_2000}.  The dilated recurrent models and skip RNN have 9 layers and 20 hidden units per layer.  The number of skips at each layer of skip RNN is 256.  The dilated CNN has 10 layers and 11 layers for $T=1,000$ and $T=2,000$, respectively.  This expands the receptive field size of the dilated CNN to the entire input sequence.  The number of filters per layer is 20. It is worth mentioning that, in the case of $T=2,000$, if we use a 10-layer dilated CNN instead, it will only produce random guesses.  This is because the output node only sees the last $1,024$ input samples which do not contain any informative data.  All the other reported models have the same hyperparameters as shown in the first three row of table \ref{table:pxiel-mnist}.  We found that none of the models without skip connections is able to learn.  Although skip Vanilla remains learning, its performance drops compared to the first unpermuted setup.  On the contrary, the \algname and dilated CNN models obtain almost the same performances as before.  It is also worth mentioning that in all three experiments, the \algname models are able to achieve comparable results with an extremely small number of parameters.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\textwidth]{./figure/noisy_1000_2000_test_only.png}
  \vspace*{-0.0725in}
  \caption{Results of the noisy MNIST task with $T=1000$ (left) and $2000$ (right). RNN models without skip connections fail. \algname significant outperforms regular recurrent skips and on-pars with the dilated CNN.  }
  \label{fig:noisy_1000_2000}
  \vspace*{-0.15in}
\end{figure}

\begin{table}[t]
\footnotesize
\centering
\caption{Results for unpermuted and permuted pixel-by-pixel MNIST. Italic numbers indicate the results copied from the original paper. The best results are bold. }
\label{table:pxiel-mnist}
\begin{tabular}{lcccccc}
\hline
Method                                    & \#     & hidden /     & \# parameters  & Max       & Unpermuted    & Permunted    \\
\multicolumn{1}{c}{}                      & layers & layer        & ($\approx$, k) & dilations & test accuracy      & test accuracy      \\ \hline \hline
Vanilla RNN                               & 1 / 9  & 256 / 20     & 68 / 7         & 1         & - / 49.1      & 71.6 / 88.5   \\
LSTM \cite{wisdom2016full}                & 1 / 9  & 256 / 20     & 270 / 28       & 1         & \textit{98.2} / 98.7   & 91.7 / 89.5   \\
GRU                                       & 1 / 9  & 256 / 20     & 200 / 21       & 1         & 99.1 / 98.8   & 94.1 / 91.3   \\
IRNN \cite{le2015simple}                  & 1      & 100          & 12             & 1         & \textit{97.0} & $\approx$\textit{82.0} \\
Full uRNN \cite{wisdom2016full}           & 1      & 512          & 270            & 1         & \textit{97.5} & 94.1          \\
Skipped RNN \cite{zhang2016architectural} & 1 / 9  & 95 / 20      & 16 / 11        & 21 / 256  & \textit{98.1} / 85.4   & \textit{94.0} / 91.8   \\
Zoneout \cite{krueger2016zoneout}         & 1      & 100          & 42             & 1         & -             & \textit{93.1} / \textit{95.9}\tablefootnote{with recurrent batch norm \cite{semeniuta2016recurrent}.}   \\
Dilated CNN \cite{van2016wavenet}         & 10     & 20 / 50   & 7 / 46         & 512       & 98.0 / 98.3   & 95.7 / {\bf 96.7}   \\
Dilated Vanilla                               & 9      & 20 / 50 & 7 / 44         & 256       & 97.7 / 98.0   & 95.5 / 96.1   \\
Dilated LSTM                              & 9      & 20 / 50 & 28 / 173       & 256       & 98. 9 / 98.9  & 94.2 / 95.4   \\
Dilated GRU                               & 9      & 20 / 50 & 21 / 130       & 256       & 99.0 / {\bf 99.2}   & 94.4 / 94.6   \\ \hline
\end{tabular}
\vspace*{-0.05in}
\end{table}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Language modeling}
We further investigate the task of predicting the next character on the Penn Treebank dataset \cite{marcus1993building}.  We follow the data splitting rule with the sequence length of 100 that are commonly used in previous studies. This corpus contains 1 million words, which is small and prone to over-fitting. Therefore model regularization methods have been shown effective on the validation and test set performances. Unlike many existing approaches, we apply no regularization other than a dropout on the input layer. Instead, we focus on investigating the regularization effect of the dilated structure itself.   Results are shown in table \ref{table:penn_tree}.   Although Zoneout, LayerNorm HM-LSTM and HyperNetowrks outperform the \algname models, they apply batch or layer normalizations as regularization. To the best of our knowledge, the dilated GRU with 1.27 BPC achieves the best result among models of similar sizes without layer normalizations. Also, the dilated models outperform their regular counterparts, Vanilla (didn't converge, omitted), LSTM and GRU, without increasing the model complexity.

\begin{table}[t]
\vspace*{-0.05in}
\footnotesize
\centering
\caption{Character-level language modeling on the Penn Tree Bank dataset.}
\label{table:penn_tree}
\begin{tabular}{lcccccc}
\hline
Method                                               & \#     & hidden   & \# parameters  & Max       & Evaluation  \\
                                                     & layers & / layer  & ($\approx$, M) & dilations & BPC         \\ \hline \hline
LSTM                                                 & 1 / 5  & 1k / 256 & 4.25 / 1.9     & 1         & 1.31 / 1.33 \\
GRU                                                  & 1 / 5  & 1k / 256 & 3.19 / 1.42    & 1         & 1.32 / 1.33 \\
Recurrent BN-LSTM \cite{cooijmans2016recurrent}      & 1      & 1k       & -              & 1         & \textit{1.32}        \\
Recurrent dropout LSTM \cite{semeniuta2016recurrent} & 1      & 1k       & 4.25              & 1         & \textit{1.30}        \\
Zoneout \cite{krueger2016zoneout}                    & 1      & 1k       & 4.25              & 1         & \textit{1.27}        \\
LayerNorm HM-LSTM \cite{chung2016hierarchical}       & 3      & 512      & -              & 1         & \textit{1.24}        \\
HyperNetworks \cite{ha2016hypernetworks}             & 1 / 2      & 1k       & 4.91 / 14.41           & 1        & \textit{1.26} / \textit{\textbf{1.22}}\tablefootnote{with layer normalization \cite{ba2016layer}.}          \\
Dilated Vanilla                                      & 5      & 256      & 0.6            & 64        & 1.37        \\
Dilated LSTM                                         & 5      & 256      & 1.9            & 64        & 1.31        \\
Dilated GRU                                          & 5      & 256      & 1.42           & 64        & 1.27        \\ \hline
\end{tabular}
\vspace*{-0.15in}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Speaker identification from raw waveform}
We also perform the speaker identification task using the corpus from VCTK \cite{yamagishi2012vctk}.  Learning audio models directly from the raw waveform poses a difficult challenge for recurrent models because of the vastly long-term dependency. Recently the CLDNN family of models \cite{sainath2015learning} managed to match or surpass the log mel-frequency features in several speech problems using waveform. However, CLDNNs coarsen the temporal granularity by pooling the first-layer CNN output before feeding it into the subsequent RNN layers, so as to solve the memory challenge. Instead, the \algname directly works on the raw waveform without pooling, which is considered more difficult. 

To achieve a feasible training time, we adopt the efficient generalization of the \algname as proposed in equation \eqref{eq:drnn_general} with $l_0 = 3$ and $l_0 = 5$ .  As mentioned before, if the dilations do not start at one, the model is equivalent to multiple shared-weight networks, each working on partial inputs, and the predictions are made by fusing the information using a 1-by-$M^{l_0}$ convolutional layer.   Our baseline GRU model follows the same setting with various resolutions (referred to as fused-GRU), with dilation starting at 8. This baseline has 8 share-weight GRU networks, and each subnetwork works on 1/8 of the subsampled sequences.   The same fusion layer is used to obtain the final prediction.   Since most other regular baselines failed to converge, we also implemented the MFCC-based models on the same task setting for reference.   The 13-dimensional log-mel frequency features are computed with 25ms window and 5ms shift.  The inputs of MFCC models are of length 100 to match the input duration in the waveform-based models.  The MFCC feature has two natural advantages: 1) no information loss from operating on subsequences;  2) shorter sequence length.  Nevertheless, our dilated models operating directly on the waveform still offer a competitive performance (Table \ref{table:speaker_id}).


\begin{table}[t]
\footnotesize
\centering
\caption{Speaker identification on the VCTK dataset.}
\label{table:speaker_id}
\begin{tabular}{llccccccc}
\hline
                                         & Method      & \#     & hidden   & \# parameters  & Min       & Max       & Evaluation  \\
                                         &             & layers & / layer  & ($\approx$, k) & dilations & dilations & accuracy    \\ \hline \hline
MFCC                                     & GRU & 5 / 1  & 20 / 128 & 16 / 68        & 1         & 1         & 0.66 / \textbf{0.77} \\
\multicolumn{1}{c}{\multirow{2}{*}{Raw}} & Fused GRU   & 1      & 256      & 225            & 32 / 8    & 32 /8     & 0.45 / 0.65 \\
\multicolumn{1}{c}{}                     & Dilated GRU & 6 / 8  & 50       & 103 / 133      & 32 / 8    & 1024      & 0.64 / 0.74 \\ \hline
\end{tabular}
\vspace*{-0.05in}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\textwidth]{./figure/increase.png}
  \vspace*{-0.05in}  
  \caption{Results for dilated vanilla with different numbers of layers on the noisy MNIST dataset.  The performance and convergent speed increase as the number of layers increases. }
  \label{fig:increase}
  \vspace*{-0.05in}
\end{figure}

In this subsection, we first investigate the relationship between performance and the number of dilations.  We compare the \algname models with different numbers of layers on the noisy MNIST $T = 1,000$ task.  All models use vanilla RNN cells with hidden state size 20.    The number of dilations starts at one.  In figure \ref{fig:increase}, we observe that the classification accuracy and rate of convergence increases as the models become deeper.  Recall the maximum skip is exponential in the number of layers.  Thus, the deeper model has a larger maximum skip and mean recurrent length.

Second, we consider maintaining a large maximum skip with a smaller number of layers, by increasing the dilation at the bottom layer of \algname.  First, we construct a nine-layer \algname model with vanilla RNN cells.  The number of dilations starts at 1, and hidden state size is 20. This architecture is referred to as ``starts at 1'' in figure \ref{fig:decrease}.  Then, we remove the bottom hidden layers one-by-one to construct seven new models.  The last created model has three layers, and the number of dilations starts at 64.   Figure \ref{fig:decrease} demonstrates both the wall time and evaluation accuracy for 50,000 training iterations of noisy MNIST dataset.  The training time reduces by roughly 50\% for every dropped layer (for every doubling of the minimum dilation).  Although the testing performance decreases when the dilation does not start at one, the effect is marginal with $s^{(0)}=2$, and small with $4\le s^{(0)}\le 16$.  Notably, the model with dilation starting at 64 is able to train within 17 minutes by using a single Nvidia P-100 GPU while maintaining a 93.5\% test accuracy.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\textwidth]{./figure/decrease.png}
  \vspace*{-0.05in}
  \caption{Training time (left) and evaluation performance (right) for dilated vanilla that starts at different numbers of dilations at the bottom layer. The maximum dilations for all models are 256.  }
  \label{fig:decrease}
 \vspace*{-0.05in}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
Our experiments with \algname provide strong evidence that this simple multi-timescale architectural choice can reliably improve the ability of recurrent models to learn long-term dependency in problems from different domains. We found that the \algname trains faster, requires less hyperparameter tuning, and needs fewer parameters to achieve the state-of-the-arts.  In complement to the experimental results, we have provided a theoretical analysis showing the advantages of \algname and proved its optimality under a meaningful architectural measure of RNNs. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgement}
Authors would like to thank Tom Le Paine (\texttt{paine1@illinois.edu}) and Ryan Musa (\texttt{ramusa@us.ibm.com}) for their insightful discussions.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{
\small
\bibliographystyle{plain}
\bibliography{drnn}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPENDIX
\newpage
\section*{Supplementary Material: Dilated Recurrent Neural Networks}
\section*{Appendix}
\appendix
\section{Mean Recurrent Length}
\label{appendix:mean_recurrent_length}
This appendix gives the detailed derivation of the conclusions in section \ref{subsec:mem_cap}. Consider two RNN architectures. One is the proposed \algname structure with $d$ layers. The other is a regular d-layer RNN with skip edges of length $2^{d-1}$ (hance $m = 2^{d-1}$), as shown in figure \ref{fig:skip-dilated-comparision}.  For the regular skip RNN, it is obvious that $\mathcal{d}_i(n)$ grows linearly within a cycle.
\begin{equation*}
\small
\mathcal{d}_i(n) = \left\{
\begin{array}{ll}
n + d & \mbox{ if } n < m \\
1 + d & \mbox{ if } n = m
\end{array}
\right.,
\end{equation*}
and therefore
\begin{equation*}
\small
\bar{\mathcal{d}} = \frac{1}{m}(\frac{m(m-1)}{2} + 1) + d = \frac{m-1}{2} + \log_2{m} + \frac{1}{m} + 1,
\end{equation*}
which grows linearly with $m$. On the other hand, for the proposed \algname structure, we have the following conclusion.
\begin{theorem}
For the \algname with $d$ layers.
\begin{equation}
\small
\mathcal{d}_i(n) = \sum_{j=0}^{d-1} b_j + d, \forall n \leq m,
\end{equation}
where {$b_0,\cdots,b_{\bar{j}}$} are digits of the binary representation of $n$, and $\bar{j}$ is the index of the highest binary bit. Thus
\begin{equation}
\small
\bar{\mathcal{d}} = \frac{3m-1}{2m} \log_2 m + \frac{1}{m} + 1.
\end{equation}
\label{thm:shortest_path}
\end{theorem}

\begin{proof}
For any path that travels from input to output through $n$ time steps consists of edges that travel through time and those that travel through layers. Therefore
\begin{equation}
\small
\mathcal{d}_i(n) = r_i(n) + d,
\label{eq:mean_length_decomp}
\end{equation}
where $r_i(n)$ is the minimum aggregate length of the edges that travel through time. $d$ is the minimum aggregate length of the edges that travel through layers, which is fixed. The problem of finding $\mathcal{d}_i(n)$ is reduced to finding $r_i(n)$, which can then be reformulated as the change-making problem: Given a set of banknotes valued $\{ 2^0, 2^1, \cdots 2^{d-1} \}$ and an amount $n$. Denote the number of each banknote $\{ a_1, \cdot, a_d$ make the amount, such that the total number of banknotes used is minimized. Formally
\begin{equation}
\small
\min_{\{a_i\}} \sum_{j=1}^d a_j, \qquad \mbox{s.t.} \sum_{i=j}^d a_j 2^{j-1} = n
\label{eq:optimization}
.\end{equation}
Since dilations $s_i$'s are multiples of each other, the simple greedy algorithm suffices to find out the shortest path spanning $n$ time steps. That is, first use the largest skip edge, $s_d$, $\lfloor n / s_d \rfloor$ times, and then use the rest of the dilations to fit the residuals. This process is analogous to converting $n$ into its binary representation. Hence the optimal solution to equation \eqref{eq:optimization}, $\{a_i^*\}$ is given by
\begin{equation}
a_i^* = b_i.
\end{equation}
For $n$ traversing $1$ through $m$, each $a_i^*$ will be $1$ 50\% of the time, except for $a_{d-1}^*$, which equals one only once. Therefore
\begin{equation}
\small
\bar{\mathcal{d}} = \frac{1}{m} (\frac{m-1}{2}(d-1) + 1 ) + d = \frac{3m-1}{2m} \log_2 m + \frac{1}{m} + 1.
\end{equation}

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Optimality of the Proposed Skip Distribution}
\label{appendix:optimality}
This appendix provides the proof to theorem \ref{thm:efficiency}. By analogy to the change-making problem, this theorem can be reformulated as the optimal denomination problem, which involves finding the a set of banknote denominations $1=s_1 \leq s_2 \leq \cdots \leq s_L=m$ such that the average number of banknotes for making the change of values ranging from $1$ to $m$, i.e. $\bar{\mathcal{d}}$, is minimized.

The optimal denomination problem remains to be an open problem in mathematics, but solutions are readily available when the candidate denominations are confined to those satisfying equation \eqref{eq:skip_ratio}, as shown in \cite{caianiello1982systemic}. The proof here is adapted from that in \cite{caianiello1982systemic}.

{\bf Proof to theorem \ref{thm:efficiency}:}
\begin{proof}
\vspace*{-0.05in}
First, it is easy to show that the RNN architecture that minimizes $\bar{\mathcal{d}}$ must have the same dilation rate within the same layer, because 1) it has all the paths that consist of all the combinations of recurrent edges with different dilations, where the optimal shortest paths must lie; 2) in such architectures $d_i(n)$ does not depend on $i$, so that the maximum over $i$ in equation \eqref{eq:recur_len} does not have an effect.
  
Now that we have confined the candidate set, the problem is reduced to finding a set of $1=s_1 \leq s_2 \leq \cdots \leq s_L=m$ such that $\bar{\mathcal{d}}$ is minimized. We can apply equation \eqref{eq:mean_length_decomp},
\begin{equation}
\small
r_i(n) = \argmin_{\{a_i\}} \sum_{j=1}^d a_i, \qquad\mbox{s.t. } \sum_j a_j s_j = n.
\end{equation}
Define
\begin{equation}
\small
\bar{r}=\frac{1}{m} \sum_{n=1}^{m} \max_i r_i(n),
\end{equation}
as the average number of recurrent edge usage. Hence minimizing $\bar{\mathcal{d}}$ is further reduced to minimizing $\bar{r}$.  Since dilations $s_i$'s are multiples of each other, the simple greedy algorithm suffices to find out the shortest path spanning $n$ time steps. That is, first use the largest skip edge, $s_d$, $\lfloor n / s_d \rfloor$ times, and then use the rest of the skip lengths to fit the residuals. Therefore, to fit all the time spans ranging from $0$ to $m-1$, the histogram of uses of recurrent edge of length $s_i<m$ per time span is distributed uniformly across 0 through $s_{i+1}/s_i$ time. Formally, the total uses of recurrent skips of length $s_i<m$ is
\begin{equation}
\small
\frac{m}{2} (\frac{s_{i+1}}{s_{i}} - 1).
\end{equation}
To fit the time span $m$, only the edge $s_d = m$ will be used once. Hence
\begin{equation}
\small
\bar{r} = \frac{1}{2} (\sum_{i=1}^{d-1} \frac{s_{i+1}}{s_i} - d + 1 ).
\end{equation}
Since the arithmetic mean is alway greater than or equal to the geometric mean
\begin{equation}
\small
\sum_{i=1}^{d-1} \frac{s_{i+1}}{s_i} \geq \sqrt[d-1]{m} = M,
\end{equation}
with equality if and only if
\begin{equation}
\small
\frac{s_{i+1}}{s_i} = M, \forall i.
\end{equation}
  
\end{proof}

\end{document}